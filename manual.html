<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>

<head>
<title>Lua 5.3 参考手册(新手版)</title>
<link rel="stylesheet" type="text/css" href="lua.css">
<link rel="stylesheet" type="text/css" href="manual.css">
<META HTTP-EQUIV="content-type" CONTENT="text/html; charset=utf-8">
</head>

<body>

<hr>
<h1>
<a href="http://www.lua.org/"><img src="logo.gif" alt="" border="0"></a>
Lua 5.3 参考手册(新手版)
</h1>

作者 Roberto Ierusalimschy, Luiz Henrique de Figueiredo, Waldemar Celes
<p>
译者 <a href="http://blog.codingnow.com">云风</a>
<p>
<small>
Lua.org, PUC-Rio 版权所有 &copy; 2015 ，
在遵循
<A HREF="http://www.lua.org/license.html">Lua license</A>
条款下，可自由使用。
</small>
<hr>
<p>

<a href="contents.html#contents">目录</A>
&middot;
<a href="contents.html#index">索引</A>
&middot;
<A HREF="glossary.html">中英术语对照表</A>

<!-- ====================================================================== -->
<p>

<!-- $Id: manual.of,v 1.146 2015/01/06 11:23:01 roberto Exp $ -->


<h1>2 &ndash; <a name="2">基本概念</a></h1>

<p>
本章描述了语言的基本概念。



<h2>2.1 &ndash; <a name="2.1">值与类型</a></h2>

<p>
Lua 是一门<em>动态类型语言</em>。
这意味着变量没有类型；只有值才有类型。
语言中不设类型定义。
所有的值携带自己的类型。


<p>
Lua 中所有的值都是 <em>一等公民</em>。
这意味着所有的值均可保存在变量中、
当作参数传递给其它函数、以及作为返回值。


<p>
Lua 中有八种基本类型：
<em>nil</em>、<em>boolean</em>、<em>number</em>、<em>string</em>、<em>function</em>、<em>userdata</em>、
<em>thread</em> 和 <em>table</em>。
<em>Nil</em> 是值 <b>nil</b> 的类型，
其主要特征就是和其它值区别开；通常用来表示一个有意义的值不存在时的状态。
<em>Boolean</em> 是 <b>false</b> 与 <b>true</b> 两个值的类型。
<b>nil</b> 和 <b>false</b> 都会导致条件判断为假；
而其它任何值都表示为真。
<em>Number</em> 代表了整数和实数（浮点数）。
<em>String</em> 表示一个不可变的字节序列。

Lua 对 8 位是友好的：
字符串可以容纳任意 8 位值，
其中包含零 ('<code>\0</code>') 。
Lua 的字符串与编码无关；
它不关心字符串中具体内容。


<p>
<em>number</em> 类型有两种内部表现方式，
 <em>整数</em> 和 <em>浮点数</em>。
对于何时使用哪种内部形式，Lua 有明确的规则，
但它也按需（参见 <a href="#3.4.3">&sect;3.4.3</a>）作自动转换。
因此，程序员多数情况下可以选择忽略整数与浮点数之间的差异或者假设完全控制每个数字的内部表现方式。
标准 Lua 使用 64 位整数和双精度（64 位）浮点数，
但你也可以把 Lua 编译成使用 32 位整数和单精度（32 位）浮点数。
以 32 位表示数字对小型机器以及嵌入式系统特别合适。
（参见 <code>luaconf.h</code> 文件中的宏 <code>LUA_32BITS</code> 。）


<p>
Lua 可以调用（以及操作）用 Lua 或 C （参见 <a href="#3.4.10">&sect;3.4.10</a>）编写的函数。
这两种函数有统一类型 <em>function</em>。


<p>
<em>userdata</em> 类型允许将 C 中的数据保存在 Lua 变量中。
用户数据类型的值是一个内存块，
有两种用户数据：
<em>完全用户数据</em> ，指一块由 Lua 管理的内存对应的对象；
<em>轻量用户数据</em> ，则指一个简单的 C 指针。
用户数据在 Lua 中除了赋值与相等性判断之外没有其他预定义的操作。
通过使用 <em>元表</em> ，程序员可以给完全用户数据定义一系列的操作
（参见 <a href="#2.4">&sect;2.4</a>）。
你只能通过 C API 而无法在 Lua 代码中创建或者修改用户数据的值，
这保证了数据仅被宿主程序所控制。


<p>
<em>thread</em> 类型表示了一个独立的执行序列，被用于实现协程
（参见 <a href="#2.6">&sect;2.6</a>）。
Lua 的线程与操作系统的线程毫无关系。
Lua 为所有的系统，包括那些不支持原生线程的系统，提供了协程支持。


<p>
<em>table</em> 是一个关联数组，
也就是说，这个数组不仅仅以数字做索引，除了 <b>nil</b> 和 NaN 之外的所有 Lua 值
都可以做索引。
（<em>Not a Number</em> 是一个特殊的数字，它用于表示未定义或表示不了的运算结果，比如 <code>0/0</code>。）
表可以是 <em>异构</em> 的；
也就是说，表内可以包含任何类型的值（ <b>nil</b> 除外）。
任何键的值若为 <b>nil</b> 就不会被记入表结构内部。
换言之，对于表内不存在的键，都对应着值 <b>nil</b> 。


<p>
表是 Lua 中唯一的数据结构，
它可被用于表示普通数组、序列、符号表、集合、记录、图、树等等。
对于记录，Lua 使用域名作为索引。
语言提供了 <code>a.name</code> 这样的语法糖来替代
<code>a["name"]</code> 这种写法以方便记录这种结构的使用。
在 Lua 中有多种便利的方式创建表（参见 <a href="#3.4.9">&sect;3.4.9</a>）。


<p>
我们使用 <em>序列</em> 这个术语来表示一个用 {1..<em>n</em>} 的正整数集做索引的表。
这里的非负整数 <em>n</em> 被称为该序列的长度（参见 <a href="#3.4.7">&sect;3.4.7</a>）。


<p>
和索引一样，表中每个域的值也可以是任何类型。
需要特别指出的是：既然函数是一等公民，那么表的域也可以是函数。
这样，表就可以携带 <em>方法</em> 了。
（参见 <a href="#3.4.11">&sect;3.4.11</a>）。


<p>
索引一张表的原则遵循语言中的直接比较规则。
当且仅当 <code>i</code> 与 <code>j</code>直接比较相等时
（即不通过元方法的比较），
表达式 <code>a[i]</code> 与 <code>a[j]</code>
表示了表中相同的元素。
特别指出：一个可以完全表示为整数的浮点数和对应的整数相等
（例如：<code>1.0 == 1</code>）。
为了消除歧义，当一个可以完全表示为整数的浮点数做为键值时，
都会被转换为对应的整数储存。
例如，当你写 <code>a[2.0] = true</code> 时，
实际被插入表中的键是整数 <code>2</code> 。
（另一方面，2 与 "<code>2</code>" 是两个不同的 Lua 值，
故而它们可以是同一张表中的不同项。）


<p>
表、函数、线程、以及完全用户数据在 Lua 中被称为 <em>对象</em>：
变量并不真的 <em>持有</em> 它们的值，而仅保存了对这些对象的 <em>引用</em>。
赋值、参数传递、函数返回，都是针对引用而不是针对值的操作，
这些操作均不会做任何形式的隐式拷贝。


<p>
库函数 <a href="#pdf-type"><code>type</code></a> 用于以字符串形式返回给定值的类型。
（参见 <a href="#6.1">&sect;6.1</a>）。


<h2>2.3 &ndash; <a name="2.3">错误处理</a></h2>

<p>
由于 Lua 是一门嵌入式扩展语言，其所有行为均源于宿主程序中 C 代码对某个 Lua 库函数的调用。
（单独使用 Lua 时，<code>lua</code> 程序就是宿主程序。）
所以，在编译或运行 Lua 代码块的过程中，无论何时发生错误，
控制权都返回给宿主，由宿主负责采取恰当的措施（比如打印错误消息）。


<p>
可以在 Lua 代码中调用 <a href="#pdf-error"><code>error</code></a> 函数来显式地抛出一个错误。
如果你需要在 Lua 中捕获这些错误，
可以使用 <a href="#pdf-pcall"><code>pcall</code></a> 或
<a href="#pdf-xpcall"><code>xpcall</code></a>
在 <em>保护模式</em> 下调用一个函数。


<p>
无论何时出现错误，都会抛出一个携带错误信息的 <em>错误对象</em> 
（<em>错误消息</em>）。
Lua 本身只会为错误生成字符串类型的错误对象，
但你的程序可以为错误生成任何类型的错误对象，
这就看你的 Lua 程序或宿主程序如何处理这些错误对象。

<p>
使用 <a href="#pdf-xpcall"><code>xpcall</code></a> 或
<a href="#lua_pcall"><code>lua_pcall</code></a> 时，
你应该提供一个 <em>消息处理函数</em> 用于错误抛出时调用。
该函数需接收原始的错误消息，并返回一个新的错误消息。
它在错误发生后栈尚未展开时调用，
因此可以利用栈来收集更多的信息，
比如通过探知栈来创建一组栈回溯信息。
同时，该处理函数也处于保护模式下，所以该函数内发生的错误会再次触发它（递归）。
如果递归太深，Lua 会终止调用并返回一个合适的消息。

<h1>3 &ndash; <a name="3">语言定义</a></h1>

<p>
这一章描述了 Lua 的词法、语法和句法。
换句话说，本章描述哪些符记是有效的，
它们如何被组合起来，这些组合方式有什么含义。


<p>
关于语言的构成概念将用常见的扩展 BNF 表达式写出。
也就是这个样子：
{<em>a</em>} 表示 0 或多个 <em>a</em>，
[<em>a</em>] 表示一个可选的 <em>a</em>。

可以被分解的非最终符号会这样写 non-terminal ，
关键字会写成这样 <b>kword</b>，
而其它不能被分解的最终符号则写成这样 &lsquo;<b>=</b>&rsquo; 。
完整的 Lua 语法可以在本手册最后一章 <a href="#9">&sect;9</a> 找到。



<h2>3.1 &ndash; <a name="3.1">词法约定</a></h2>

<p>
Lua 语言的格式自由。
它会忽略语法元素（符记）间的空格（包括换行）和注释，
仅把它们看作为名字和关键字间的分割符。


<p>
Lua 中的 <em>名字</em>
（也被称为 <em>标识符</em>）
可以是由非数字打头的任意字母下划线和数字构成的字符串。
标识符可用于对变量、表的域、以及标签命名。


<p>
下列 <em>关键字</em> 是保留的，不可用于名字：


<pre>
     and       break     do        else      elseif    end
     false     for       function  goto      if        in
     local     nil       not       or        repeat    return
     then      true      until     while
</pre>

<p>
Lua 语言对大小写敏感：
<code>and</code> 是一个保留字，但 <code>And</code> 与 <code>AND</code>
则是两个不同的有效名字。
作为一个约定，程序应避免创建以下划线加一个或多个大写字母构成的名字
（例如 <a href="#pdf-_VERSION"><code>_VERSION</code></a>）。


<p>
下列字符串是另外一些符记：

<pre>
     +     -     *     /     %     ^     #
     &amp;     ~     |     &lt;&lt;    &gt;&gt;    //
     ==    ~=    &lt;=    &gt;=    &lt;     &gt;     =
     (     )     {     }     [     ]     ::
     ;     :     ,     .     ..    ...
</pre>

<p>
<em>字面串</em> 可以用单引号或双引号括起。
字面串内部可以包含下列 C 风格的转义串： 
'<code>\a</code>' （响铃），
'<code>\b</code>' （退格），
'<code>\f</code>' （换页），
'<code>\n</code>' （换行），
'<code>\r</code>' （回车），
'<code>\t</code>' （横项制表），
'<code>\v</code>' （纵向制表），
'<code>\\</code>' （反斜杠），
'<code>\"</code>' （双引号），
以及 '<code>\'</code>' (单引号)。
在反斜杠后跟一个真正的换行等价于在字符串中写一个换行符。
转义串 '<code>\z</code>' 会忽略其后的一系列空白符，包括换行；
它在你需要对一个很长的字符串常量断行为多行并希望在每个新行保持缩进时非常有用。



<p>
Lua 中的字符串可以保存任意 8 位值，其中包括用 '<code>\0</code>' 表示的 0 。
一般而言，你可以用字符的数字值来表示这个字符。
方式是用转义串 <code>\x<em>XX</em></code>，
此处的 <em>XX</em> 必须是恰好两个字符的 16 进制数。
或者你也可以使用转义串 <code>\<em>ddd</em></code> ，
这里的 <em>ddd</em> 是一到三个十进制数字。
（注意，如果在转义符后接着恰巧是一个数字符号的话，
你就必须在这个转义形式中写满三个数字。）


<p>
对于用 UTF-8 编码的 Unicode 字符，你可以用
转义符 <code>\u{<em>XXX</em>}</code> 来表示
（这里必须有一对花括号），
此处的 <em>XXX</em> 是用 16 进制表示的字符编号。


<p>
字面串还可以用一种 <em>长括号</em> 括起来的方式定义。
我们把两个正的方括号间插入 <em>n</em> 个等号定义为 <em>第 <em>n</em> 级开长括号</em>。
就是说，0 级开的长括号写作 <code>[[</code> ， 一级开长括号写作 <code>[=[</code> ，
如此等等。
<em>闭长括号</em>也作类似定义； 
举个例子，4 级反的长括号写作 <code>]====]</code> 。
一个 <em>长字面串</em> 可以由任何一级的开长括号开始，而由第一个碰到的同级的闭长括号结束。
这种方式描述的字符串可以包含任何东西，当然特定级别的反长括号除外。
整个词法分析过程将不受分行限制，不处理任何转义符，并且忽略掉任何不同级别的长括号。 
其中碰到的任何形式的换行串（回车、换行、回车加换行、换行加回车），都会被转换为单个换行符。


<p>
字面串中的每个不被上述规则影响的字节都呈现为本身。
然而，Lua 是用文本模式打开源文件解析的，
一些系统的文件操作函数对某些控制字符的处理可能有问题。
因此，对于非文本数据，用引号括起来并显式按转义符规则来表述更安全。


<p>
为了方便起见，
当一个开长括号后紧接一个换行符时，
这个换行符不会放在字符串内。
举个例子，假设一个系统使用 ASCII 码
（此时 '<code>a</code>' 编码为 97 ，
换行编码为 10 ，'<code>1</code>' 编码为 49 ），
下面五种方式描述了完全相同的字符串：

<pre>
     a = 'alo\n123"'
     a = "alo\n123\""
     a = '\97lo\10\04923"'
     a = [[alo
     123"]]
     a = [==[
     alo
     123"]==]
</pre>

<p>
<em>数字常量</em> （或称为 <em>数字量</em>）
可以由可选的小数部分和可选的十为底的指数部分构成，
指数部分用字符 '<code>e</code>' 或 '<code>E</code>' 来标记。
Lua 也接受以 <code>0x</code> 或 <code>0X</code> 开头的 16 进制常量。
16 进制常量也接受小数加指数部分的形式，指数部分是以二为底，
用字符 '<code>p</code>' 或 '<code>P</code>' 来标记。
数字常量中包含小数点或指数部分时，被认为是一个浮点数；
否则被认为是一个整数。
下面有一些合法的整数常量的例子：
<pre>
     3   345   0xff   0xBEBADA
</pre><p>
以下为合法的浮点常量：
<pre>
     3.0     3.1416     314.16e-2     0.31416E1     34e1
     0x0.1E  0xA23p-4   0X1.921FB54442D18P+1
</pre>

<p>
在字符串外的任何地方出现以双横线 (<code>--</code>) 开头的部分是 <em>注释</em> 。
如果 <code>--</code> 后没有紧跟着一个开大括号，
该注释为 <em>短注释</em>，
注释到当前行末截至。
否则，这是一段 <em>长注释</em> ，
注释区一直维持到对应的闭长括号。
长注释通常用于临时屏蔽掉一大段代码。



<h2>3.2 &ndash; <a name="3.2">变量</a></h2>

<p>
变量是储存值的地方。
Lua 中有三种变量：
全局变量、局部变量和表的域。


<p>
单个名字可以指代一个全局变量也可以指代一个局部变量
（或者是一个函数的形参，这是一种特殊形式的局部变量）。

<pre>
	var ::= Name
</pre><p>
名字指 <a href="#3.1">&sect;3.1</a> 中定义的标识符。


<p>
所有没有显式声明为局部变量（参见 <a href="#3.3.7">&sect;3.3.7</a>）
的变量名都被当做全局变量。
局部变量有其 <em>作用范围</em> ：
局部变量可以被定义在它作用范围中的函数自由使用（参见
<a href="#3.5">&sect;3.5</a>）。


<p>
在变量的首次赋值之前，变量的值均为 <b>nil</b>。


<p>
方括号被用来对表作索引：

<pre>
	var ::= prefixexp &lsquo;<b>[</b>&rsquo; exp &lsquo;<b>]</b>&rsquo;
</pre><p>
对全局变量以及表的域之访问的含义可以通过元表来改变。 
以索引方式访问一个变量 <code>t[i]</code> 等价于
调用 <code>gettable_event(t,i)</code>。
（参见 <a href="#2.4">&sect;2.4</a> ，有一份完整的关于
<code>gettable_event</code> 函数的说明。
这个函数并没有在 lua 中定义出来，也不能在 lua 中调用。这里我们把提到它只是方便说明问题。）


<p>
<code>var.Name</code> 这种语法只是一个语法糖，用来表示
<code>var["Name"]</code>：

<pre>
	var ::= prefixexp &lsquo;<b>.</b>&rsquo; Name
</pre>

<p>
对全局变量 <code>x</code> 的操作等价于操作
<code>_ENV.x</code>。
由于代码块编译的方式，
<code>_ENV</code> 永远也不可能是一个全局名字 （参见 <a href="#2.2">&sect;2.2</a>）。





<h2>3.3 &ndash; <a name="3.3">语句</a></h2>

<p>
Lua 支持所有与 Pascal 或是 C 类似的常见形式的语句，
这个集合包括赋值，控制结构，函数调用，还有变量声明。



<h3>3.3.1 &ndash; <a name="3.3.1">语句块</a></h3>

<p>
语句块是一个语句序列，它们会按次序执行：

<pre>
	block ::= {stat}
</pre><p>
Lua 支持 <em>空语句</em>，
你可以用分号分割语句，也可以以分号开始一个语句块，
或是连着写两个分号：

<pre>
	stat ::= &lsquo;<b>;</b>&rsquo;
</pre>

<p>
函数调用和赋值语句都可能以一个小括号打头，
这可能让 Lua 的语法产生歧义。
我们来看看下面的代码片断：

<pre>
     a = b + c
     (print or io.write)('done')
</pre><p>
从语法上说，可能有两种解释方式：

<pre>
     a = b + c(print or io.write)('done')
     
     a = b + c; (print or io.write)('done')
</pre><p>
当前的解析器总是用第一种结构来解析，
它会将开括号看成函数调用的参数传递开始处。
为了避免这种二义性，
在一条语句以小括号开头时，前面放一个分号是个好习惯：

<pre>
     ;(print or io.write)('done')
</pre>

<p>

一个语句块可以被显式的定界为单条语句：

<pre>
	stat ::= <b>do</b> block <b>end</b>
</pre><p>
显式的对一个块定界通常用来控制内部变量声明的作用域。
有时，显式定界也用于在一个语句块中间插入
<b>return</b> （参见 <a href="#3.3.4">&sect;3.3.4</a>）。





<h3>3.3.2 &ndash; <a name="3.3.2">代码块</a></h3>

<p>
Lua 的一个编译单元被称为一个 <em>代码块</em>。
从句法构成上讲，一个代码块就是一个语句块。

<pre>
	chunk ::= block
</pre>

<p>
Lua 把一个代码块当作一个拥有不定参数的匿名函数
（参见<a href="#3.4.11">&sect;3.4.11</a>）来处理。
正是这样，代码块内可以定义局部变量，它可以接收参数，返回若干值。
此外，这个匿名函数在编译时还为它的作用域绑定了一个外部局部变量
<code>_ENV</code> （参见 <a href="#2.2">&sect;2.2</a>）。
该函数总是把 <code>_ENV</code> 作为它唯一的一个上值，
即使这个函数不使用这个变量，它也存在。


<p>
代码块可以被保存在文件中，也可以作为宿主程序内部的一个字符串。
要执行一个代码块，
首先要让 Lua <em>加载</em> 它，
将代码块中的代码预编译成虚拟机中的指令，
而后，Lua 用虚拟机解释器来运行编译后的代码。


<p>
代码块可以被预编译为二进制形式；
参见程序  <code>luac</code> 以及函数 <a href="#pdf-string.dump"><code>string.dump</code></a> 可获得更多细节。
用源码表示的程序和编译后的形式可自由替换；
Lua 会自动检测文件格式做相应的处理
（参见 <a href="#pdf-load"><code>load</code></a>）。





<h3>3.3.3 &ndash; <a name="3.3.3">赋值</a></h3>

<p>
Lua 允许多重赋值。
因此，赋值的语法定义是等号左边放一个变量列表， 而等号右边放一个表达式列表。
两边的列表中的元素都用逗号间开：

<pre>
	stat ::= varlist &lsquo;<b>=</b>&rsquo; explist
	varlist ::= var {&lsquo;<b>,</b>&rsquo; var}
	explist ::= exp {&lsquo;<b>,</b>&rsquo; exp}
</pre><p>
表达式放在 <a href="#3.4">&sect;3.4</a> 中讨论。


<p>
在作赋值操作之前，
那值列表会被 <em>调整</em> 为左边变量列表的个数。
如果值比需要的更多的话，多余的值就被扔掉。 
如果值的数量不够需求，
将会按所需扩展若干个 <b>nil</b>。
如果表达式列表以一个函数调用结束，
这个函数所返回的所有值都会在调整操作之前被置入值列表中
（除非这个函数调用被用括号括了起来；参见 <a href="#3.4">&sect;3.4</a>）。



<p>
赋值语句首先让所有的表达式完成运算，
之后再做赋值操作。
因此，下面这段代码

<pre>
     i = 3
     i, a[i] = i+1, 20
</pre><p>
会把 <code>a[3]</code> 设置为 20，而不会影响到 <code>a[4]</code> 。
这是因为 <code>a[i]</code> 中的 <code>i</code> 在被赋值为 4 之前就被计算出来了（当时是 3 ）。 
简单说 ，这样一行

<pre>
     x, y = y, x
</pre><p>
会交换 <code>x</code> 和 <code>y</code> 的值，
及

<pre>
     x, y, z = y, z, x
</pre><p>
会轮换 <code>x</code>，<code>y</code>，<code>z</code> 的值。


<p>
对全局变量以及表的域的赋值操作的含义可以通过元表来改变。
对 <code>t[i] = val</code> 这样的变量索引赋值，
等价于 <code>settable_event(t,i,val)</code>。
（关于函数 <code>settable_event</code> 的详细说明，参见
<a href="#2.4">&sect;2.4</a>。
这个函数并没有在 Lua 中定义出来，也不可以被调用。
这里我们列出来，仅仅出于方便解释的目的。）



<p>
对于全局变量 <code>x = val</code> 的赋值等价于
<code>_ENV.x = val</code>
（参见 <a href="#2.2">&sect;2.2</a>）。





<h3>3.3.4 &ndash; <a name="3.3.4">控制结构</a></h3><p>
<b>if</b>, <b>while</b>, and <b>repeat</b>
这些控制结构符合通常的意义，而且也有类似的语法：




<pre>
	stat ::= <b>while</b> exp <b>do</b> block <b>end</b>
	stat ::= <b>repeat</b> block <b>until</b> exp
	stat ::= <b>if</b> exp <b>then</b> block {<b>elseif</b> exp <b>then</b> block} [<b>else</b> block] <b>end</b>
</pre><p>
Lua 也有一个 <b>for</b> 语句，它有两种形式
（参见 <a href="#3.3.5">&sect;3.3.5</a>）。


<p>
控制结构中的条件表达式可以返回任何值。
<b>false</b> 与 <b>nil</b> 两者都被认为是假。
所有不同于 <b>nil</b> 与 <b>false</b> 的其它值都被认为是真
（特别需要注意的是，数字 0 和空字符串也被认为是真）。


<p>
在 <b>repeat</b>&ndash;<b>until</b> 循环中，
内部语句块的结束点不是在 <b>until</b> 这个关键字处，
它还包括了其后的条件表达式。
因此，条件表达式中可以使用循环内部语句块中的定义的局部变量。


<p>
<b>goto</b> 语句将程序的控制点转移到一个标签处。
由于句法上的原因，
Lua 里的标签也被认为是语句：



<pre>
	stat ::= <b>goto</b> Name
	stat ::= label
	label ::= &lsquo;<b>::</b>&rsquo; Name &lsquo;<b>::</b>&rsquo;
</pre>

<p>
除了在内嵌函数中，以及在内嵌语句块中定义了同名标签，的情况外，
标签对于它定义所在的整个语句块可见。
只要 goto 没有进入一个新的局部变量的作用域，它可以跳转到任意可见标签处。


<p>
标签和没有内容的语句被称为<em>空语句</em>，它们不做任何操作。


<p>
<b>break</b> 被用来结束
<b>while</b>、 <b>repeat</b>、或 <b>for</b> 循环，
它将跳到循环外接着之后的语句运行：


<pre>
	stat ::= <b>break</b>
</pre><p>
<b>break</b> 跳出最内层的循环。


<p>
<b>return</b> 被用于从函数或是代码块（其实它就是一个函数）
中返回值。

函数可以返回不止一个值，所以 <b>return</b> 的语法为

<pre>
	stat ::= <b>return</b> [explist] [&lsquo;<b>;</b>&rsquo;]
</pre>

<p>
<b>return</b> 只能被写在一个语句块的最后一句。
如果你真的需要从语句块的中间 <b>return</b>，
你可以使用显式的定义一个内部语句块，
一般写作 <code>do return end</code>。
可以这样写是因为现在 <b>return</b> 成了（内部）语句块的最后一句了。





<h3>3.3.5 &ndash; <a name="3.3.5">For 语句</a></h3>

<p>
<b>for</b> 有两种形式：一种是数字形式，另一种是通用形式。


<p>
数字形式的 <b>for</b> 循环，通过一个数学运算不断地运行内部的代码块。
下面是它的语法：

<pre>
	stat ::= <b>for</b> Name &lsquo;<b>=</b>&rsquo; exp &lsquo;<b>,</b>&rsquo; exp [&lsquo;<b>,</b>&rsquo; exp] <b>do</b> block <b>end</b>
</pre><p>
<em>block</em> 将把 <em>name</em> 作循环变量。
从第一个 <em>exp</em> 开始起，直到第二个 <em>exp</em> 的值为止，
其步长为第三个 <em>exp</em> 。
更确切的说，一个 <b>for</b> 循环看起来是这个样子

<pre>
     for v = <em>e1</em>, <em>e2</em>, <em>e3</em> do <em>block</em> end
</pre><p>
这等价于代码：

<pre>
     do
       local <em>var</em>, <em>limit</em>, <em>step</em> = tonumber(<em>e1</em>), tonumber(<em>e2</em>), tonumber(<em>e3</em>)
       if not (<em>var</em> and <em>limit</em> and <em>step</em>) then error() end
       <em>var</em> = <em>var</em> - <em>step</em>
       while true do
         <em>var</em> = <em>var</em> + <em>step</em>
         if (<em>step</em> &gt;= 0 and <em>var</em> &gt; <em>limit</em>) or (<em>step</em> &lt; 0 and <em>var</em> &lt; <em>limit</em>) then
           break
         end
         local v = <em>var</em>
         <em>block</em>
       end
     end
</pre>

<p>
注意下面这几点：

<ul>

<li>
所有三个控制表达式都只被运算一次，
表达式的计算在循环开始之前。 
这些表达式的结果必须是数字。
</li>

<li>
<code><em>var</em></code>，<code><em>limit</em></code>，以及 <code><em>step</em></code>
都是一些不可见的变量。 
这里给它们起的名字都仅仅用于解释方便。
</li>

<li>
如果第三个表达式（步长）没有给出，会把步长设为 1 。
</li>

<li>
你可以用 <b>break</b> 和 <b>goto</b> 来退出 <b>for</b> 循环。
</li>

<li>
循环变量 <code>v</code> 是一个循环内部的局部变量；
如果你需要在循环结束后使用这个值，
在退出循环前把它赋给另一个变量。
</li>

</ul>

<p>
通用形式的 <b>for</b> 通过一个叫作 <em>迭代器</em> 的函数工作。
每次迭代，迭代器函数都会被调用以产生一个新的值，
当这个值为 <b>nil</b> 时，循环停止。 
通用形式的 <b>for</b> 循环的语法如下：

<pre>
	stat ::= <b>for</b> namelist <b>in</b> explist <b>do</b> block <b>end</b>
	namelist ::= Name {&lsquo;<b>,</b>&rsquo; Name}
</pre><p>
这样的 <b>for</b> 语句

<pre>
     for <em>var_1</em>, &middot;&middot;&middot;, <em>var_n</em> in <em>explist</em> do <em>block</em> end
</pre><p>
它等价于这样一段代码：

<pre>
     do
       local <em>f</em>, <em>s</em>, <em>var</em> = <em>explist</em>
       while true do
         local <em>var_1</em>, &middot;&middot;&middot;, <em>var_n</em> = <em>f</em>(<em>s</em>, <em>var</em>)
         if <em>var_1</em> == nil then break end
         <em>var</em> = <em>var_1</em>
         <em>block</em>
       end
     end
</pre><p>
注意以下几点：

<ul>

<li>
<code><em>explist</em></code> 只会被计算一次。
它返回三个值， 一个 <em>迭代器</em> 函数，
一个 <em>状态</em>，
一个 <em>迭代器的初始值</em>。
</li>

<li>
<code><em>f</em></code>， <code><em>s</em></code>，与 <code><em>var</em></code>
都是不可见的变量。
这里给它们起的名字都只是为了解说方便。
</li>

<li>
你可以使用 <b>break</b> 来跳出 <b>for</b> 循环。
</li>

<li>
环变量 <code><em>var_i</em></code> 对于循环来说是一个局部变量；
你不可以在 <b>for</b> 循环结束后继续使用。
如果你需要保留这些值，那么就在循环跳出或结束前赋值到别的变量里去。
</li>

</ul>




<h3>3.3.6 &ndash; <a name="3.3.6">函数调用语句</a></h3><p>
为了允许使用函数的副作用，
函数调用可以被作为一个语句执行：

<pre>
	stat ::= functioncall
</pre><p>
在这种情况下，所有的返回值都被舍弃。
函数调用在 <a href="#3.4.10">&sect;3.4.10</a> 中解释。





<h3>3.3.7 &ndash; <a name="3.3.7">局部声明</a></h3><p>
局部变量可以在语句块中任何地方声明。 
声明可以包含一个初始化赋值操作：


<pre>
	stat ::= <b>local</b> namelist [&lsquo;<b>=</b>&rsquo; explist]
</pre><p>
如果有初始化值的话，初始化赋值操作的语法和赋值操作一致
（参见 <a href="#3.3.3">&sect;3.3.3</a> ）。
若没有初始化值，所有的变量都被初始化为 <b>nil</b>。



<p>
一个代码块同时也是一个语句块（参见 <a href="#3.3.2">&sect;3.3.2</a>），
所以局部变量可以放在代码块中那些显式注明的语句块之外。 


<p>
局部变量的可见性规则在 <a href="#3.5">&sect;3.5</a> 中解释。







<h2>3.4 &ndash; <a name="3.4">表达式</a></h2>

<p>
Lua 中有这些基本表达式：

<pre>
	exp ::= prefixexp
	exp ::= <b>nil</b> | <b>false</b> | <b>true</b>
	exp ::= Numeral
	exp ::= LiteralString
	exp ::= functiondef
	exp ::= tableconstructor
	exp ::= &lsquo;<b>...</b>&rsquo;
	exp ::= exp binop exp
	exp ::= unop exp
	prefixexp ::= var | functioncall | &lsquo;<b>(</b>&rsquo; exp &lsquo;<b>)</b>&rsquo;
</pre>

<p>
数字和字面串在 <a href="#3.1">&sect;3.1</a> 中解释；
变量在 <a href="#3.2">&sect;3.2</a> 中解释；
函数定义在 <a href="#3.4.11">&sect;3.4.11</a> 中解释；
函数调用在 <a href="#3.4.10">&sect;3.4.10</a> 中解释；
表的构造在 <a href="#3.4.9">&sect;3.4.9</a> 中解释。
可变参数的表达式写作三个点（'<code>...</code>'），
它只能在有可变参数的函数中直接使用；这些在 <a href="#3.4.11">&sect;3.4.11</a> 中解释。


<p>
二元操作符包含有数学运算操作符（参见 <a href="#3.4.1">&sect;3.4.1</a>），
位操作符（参见 <a href="#3.4.2">&sect;3.4.2</a>），
比较操作符（参见 <a href="#3.4.4">&sect;3.4.4</a>），
逻辑操作符（参见 <a href="#3.4.5">&sect;3.4.5</a>），
以及连接操作符（参见 <a href="#3.4.6">&sect;3.4.6</a>）。
一元操作符包括负号（参见 <a href="#3.4.1">&sect;3.4.1</a>），
按位非（参见 <a href="#3.4.2">&sect;3.4.2</a>），
逻辑非（参见 <a href="#3.4.5">&sect;3.4.5</a>），
和取长度操作符（参见 <a href="#3.4.7">&sect;3.4.7</a>）。



<p>
函数调用和可变参数表达式都可以放在多重返回值中。 
如果函数调用被当作一条语句（参见 <a href="#3.3.6">&sect;3.3.6</a>），
其返回值列表被调整为零个元素，即抛弃所有的返回值。
如果表达式被用于表达式列表的最后（或是唯一的）一个元素，
那么不会做任何调整（除非表达式被括号括起来）。
在其它情况下，
Lua 都会把结果调整为一个元素置入表达式列表中，
即保留第一个结果而忽略之后的所有值，或是在没有结果时，
补单个 <b>nil</b>。


<p>
这里有一些例子：

<pre>
     f()                -- 调整为 0 个结果
     g(f(), x)          -- f() 会被调整为一个结果
     g(x, f())          -- g 收到 x 以及 f() 返回的所有结果
     a,b,c = f(), x     -- f() 被调整为 1 个结果 （c 收到 nil）
     a,b = ...          -- a 收到可变参数列表的第一个参数，
                        -- b 收到第二个参数（如果可变参数列表中
                        -- 没有实际的参数，a 和 b 都会收到 nil）
     
     a,b,c = x, f()     -- f() 被调整为 2 个结果
     a,b,c = f()        -- f() 被调整为 3 个结果
     return f()         -- 返回 f() 的所有返回结果
     return ...         -- 返回从可变参数列表中接收到的所有参数parameters
     return x,y,f()     -- 返回 x, y, 以及 f() 的所有返回值
     {f()}              -- 用 f() 的所有返回值创建一个列表
     {...}              -- 用可变参数中的所有值创建一个列表
     {f(), nil}         -- f() 被调整为一个结果
</pre>

<p>
被括号括起来的表达式永远被当作一个值。
所以，
<code>(f(x,y,z))</code> 即使 <code>f</code> 返回多个值，
这个表达式永远是一个单一值。 
（<code>(f(x,y,z))</code> 的值是 <code>f</code> 返回的第一个值。
如果 <code>f</code> 不返回值的话，那么它的值就是 <b>nil</b> 。）



<h3>3.4.1 &ndash; <a name="3.4.1">数学运算操作符</a></h3><p>
Lua 支持下列数学运算操作符：

<ul>
<li><b><code>+</code>: </b>加法</li>
<li><b><code>-</code>: </b>减法</li>
<li><b><code>*</code>: </b>乘法</li>
<li><b><code>/</code>: </b>浮点除法</li>
<li><b><code>//</code>: </b>向下取整除法</li>
<li><b><code>%</code>: </b>取模</li>
<li><b><code>^</code>: </b>乘方</li>
<li><b><code>-</code>: </b>取负</li>
</ul>

<p>
除了乘方和浮点除法运算，
数学运算按如下方式工作：
如果两个操作数都是整数，
该操作以整数方式操作且结果也将是一个整数。
否则，当两个操作数都是数字或可以被转换为数字的字符串
（参见 <a href="#3.4.3">&sect;3.4.3</a>）时，
操作数会被转换成两个浮点数，
操作按通常的浮点规则（一般遵循 IEEE 754 标准）
来进行，结果也是一个浮点数。


<p>
乘方和浮点除法 （<code>/</code>）
总是把操作数转换成浮点数进行，其结果总是浮点数。
乘方使用 ISO C 函数 <code>pow</code>，
因此它也可以接受非整数的指数。


<p>
向下取整的除法 （<code>//</code>）
指做一次除法，并将商圆整到靠近负无穷的一侧，
即对操作数做除法后取 floor 。


<p>
取模被定义成除法的余数，其商被圆整到靠近负无穷的一侧（向下取整的除法）。


<p>
对于整数数学运算的溢出问题，
这些操作采取的策略是按通常遵循的以 2 为补码的数学运算的 <em>环绕</em> 规则。
（换句话说，它们返回其运算的数学结果对 <em>2<sup>64</sup></em> 取模后的数字。）



<h3>3.4.2 &ndash; <a name="3.4.2">位操作符</a></h3><p>
Lua 支持下列位操作符：

<ul>
<li><b><code>&amp;</code>: </b>按位与</li>
<li><b><code>&#124;</code>: </b>按位或</li>
<li><b><code>~</code>: </b>按位异或</li>
<li><b><code>&gt;&gt;</code>: </b>右移</li>
<li><b><code>&lt;&lt;</code>: </b>左移</li>
<li><b><code>~</code>: </b>按位非</li>
</ul>

<p>
所有的位操作都将操作数先转换为整数
（参见 <a href="#3.4.3">&sect;3.4.3</a>），
然后按位操作，其结果是一个整数。


<p>
对于右移和左移，均用零来填补空位。
移动的位数若为负，则向反方向位移；
若移动的位数的绝对值大于等于
整数本身的位数，其结果为零
（所有位都被移出）。





<h3>3.4.3 &ndash; <a name="3.4.3">强制转换</a></h3><p>
Lua 对一些类型和值的内部表示会在运行时做一些数学转换。
位操作总是将浮点操作数转换成整数。
乘方和浮点除法总是将整数转换为浮点数。
其它数学操作若针对混合操作数
（整数和浮点数）将把整数转换为浮点数；
这一点被称为 <em>通常规则</em>。
C API 同样会按需把整数转换为浮点数以及
把浮点数转换为整数。
此外，字符串连接操作除了字符串，也可以接受数字作为参数。


<p>
当操作需要数字时，Lua 还会把字符串转换为数字。


<p>
当把一个整数转换为浮点数时，
若整数值恰好可以表示为一个浮点数，那就取那个浮点数。
否则，转换会取最接近的较大值或较小值来表示这个数。
这种转换是不会失败的。


<p>
将浮点数转为整数的过程会检查
浮点数能否被准确的表达为一个整数
（即，浮点数是一个整数值且在整数可以表达的区间）。
如果可以，结果就是那个数，否则转换失败。


<p>
从字符串到数字的转换过程遵循以下流程：
首先，遵循按 Lua 词法分析器的规则分析语法来转换为对应的
整数或浮点数。
（字符串可以有前置或后置的空格以及一个符号。）
然后，结果数字再按前述规则转换为所需要的类型（浮点或整数）。


<p>
从数字转换为字符串使用非指定的人可读的格式。
若想完全控制数字到字符串的转换过程，
可以使用字符串库中的 <code>format</code> 函数
（参见 <a href="#pdf-string.format"><code>string.format</code></a>）。





<h3>3.4.4 &ndash; <a name="3.4.4">比较操作符</a></h3><p>
Lua 支持下列比较操作符：

<ul>
<li><b><code>==</code>: </b>等于</li>
<li><b><code>~=</code>: </b>不等于</li>
<li><b><code>&lt;</code>: </b>小于</li>
<li><b><code>&gt;</code>: </b>大于</li>
<li><b><code>&lt;=</code>: </b>小于等于</li>
<li><b><code>&gt;=</code>: </b>大于等于</li>
</ul><p>
这些操作的结果不是 <b>false</b> 就是 <b>true</b>。


<p>
等于操作 （<code>==</code>）先比较操作数的类型。
如果类型不同，结果就是 <b>false</b>。
否则，继续比较值。 
字符串按一般的方式比较。
数字遵循二元操作的规则：
如果两个操作数都是整数，
它们按整数比较；
否则，它们先转换为浮点数，然后再做比较。


<p>
表，用户数据，以及线程都按引用比较：
只有两者引用同一个对象时才认为它们相等。
每次你创建一个新对象（一张表，一个用户数据，或一个线程），
新对象都一定和已有且存在的对象不同。
相同引用的闭包一定相等。
有任何可察觉的差异（不同的行为，不同的定义）一定不等。


<p>
你可以通过使用 "eq" 元方法（参见 <a href="#2.4">&sect;2.4</a>）
来改变 Lua 比较表和用户数据时的方式。


<p>
等于操作不会将字符串转换为数字，反之亦然。
即，<code>"0"==0</code> 结果为 <b>false</b>，
且 <code>t[0]</code> 与 <code>t["0"]</code> 指代着表中的不同项。


<p>
<code>~=</code> 操作完全等价于 (<code>==</code>) 操作的反值。


<p>
大小比较操作以以下方式进行。
如果参数都是数字，
它们按二元操作的常规进行。
否则，如果两个参数都是字符串，
它们的值按当前的区域设置来比较。
再则，Lua 就试着调用 "lt" 或是 "le" 元方法
（参见 <a href="#2.4">&sect;2.4</a>）。
<code>a &gt; b</code> 的比较被转译为 <code>b &lt; a</code>，
<code>a &gt;= b</code> 被转译为 <code>b &lt;= a</code>。





<h3>3.4.5 &ndash; <a name="3.4.5">逻辑操作符</a></h3><p>
Lua 中的逻辑操作符有 <b>and</b>， <b>or</b>，以及 <b>not</b>。
和控制结构（参见 <a href="#3.3.4">&sect;3.3.4</a>）一样，
所有的逻辑操作符把 <b>false</b> 和 <b>nil</b> 都作为假，
而其它的一切都当作真。


<p>
取反操作 <b>not</b> 总是返回 <b>false</b> 或 <b>true</b> 中的一个。
与操作符 <b>and</b> 在第一个参数为 <b>false</b> 或 <b>nil</b> 时
返回这第一个参数；
否则，<b>and</b> 返回第二个参数。 
或操作符 <b>or</b> 在第一个参数不为 <b>nil</b> 也不为 <b>false</b> 时，
返回这第一个参数，否则返回第二个参数。
<b>and</b> 和 <b>or</b> 都遵循短路规则；
也就是说，第二个操作数只在需要的时候去求值。
这里有一些例子：

<pre>
     10 or 20            --&gt; 10
     10 or error()       --&gt; 10
     nil or "a"          --&gt; "a"
     nil and 10          --&gt; nil
     false and error()   --&gt; false
     false and nil       --&gt; false
     false or nil        --&gt; nil
     10 and 20           --&gt; 20
</pre><p>
（在这本手册中，
<code>--&gt;</code> 指前面表达式的结果。）





<h3>3.4.6 &ndash; <a name="3.4.6">字符串连接</a></h3><p>
Lua 中字符串的连接操作符写作两个点（'<code>..</code>'）。
如果两个操作数都是字符串或都是数字，
连接操作将以 <a href="#3.4.3">&sect;3.4.3</a> 中提到的规则把其转换为字符串。
否则，会调用元方法 <code>__concat</code> （参见 <a href="#2.4">&sect;2.4</a>）。





<h3>3.4.7 &ndash; <a name="3.4.7">取长度操作符</a></h3>

<p>
取长度操作符写作一元前置符 <code>#</code>。
字符串的长度是它的字节数（就是以一个字符一个字节计算的字符串长度）。


<p>
程序可以通过 <code>__len</code> 元方法（参见 <a href="#2.4">&sect;2.4</a>）
来修改对字符串类型外的任何值的取长度操作行为。


<p>
如果 <code>__len</code> 元方法没有给出，
表 <code>t</code> 的长度只在表是一个 <em>序列</em> 时有定义。
序列指表的正数键集等于 <em>{1..n}</em> ，
其中 <em>n</em> 是一个非负整数。
在这种情况下，<em>n</em> 是表的长度。
注意这样的表

<pre>
     {10, 20, nil, 40}
</pre><p>
不是一个序列，因为它有键 <code>4</code>
却没有键 <code>3</code>。
（因此，该表的正整数键集不等于 <em>{1..n}</em> 集合，故而就不存在 <em>n</em>。）
注意，一张表是否是一个序列和它的非数字键无关。





<h3>3.4.8 &ndash; <a name="3.4.8">优先级</a></h3><p>
Lua 中操作符的优先级写在下表中，从低到高优先级排序：

<pre>
     or
     and
     &lt;     &gt;     &lt;=    &gt;=    ~=    ==
     |
     ~
     &amp;
     &lt;&lt;    &gt;&gt;
     ..
     +     -
     *     /     //    %
     unary operators (not   #     -     ~)
     ^
</pre><p>
通常，
你可以用括号来改变运算次序。
连接操作符 ('<code>..</code>') 和乘方操作 ('<code>^</code>') 
是从右至左的。 
其它所有的操作都是从左至右。




<h3>3.4.9 &ndash; <a name="3.4.9">表构建</a></h3><p>
表构造子是一个构造表的表达式。
每次构造子被执行，都会构造出一张新的表。
构造子可以被用来构造一张空表，
也可以用来构造一张表并初始化其中的一些域。
一般的构造子的语法如下

<pre>
	tableconstructor ::= &lsquo;<b>{</b>&rsquo; [fieldlist] &lsquo;<b>}</b>&rsquo;
	fieldlist ::= field {fieldsep field} [fieldsep]
	field ::= &lsquo;<b>[</b>&rsquo; exp &lsquo;<b>]</b>&rsquo; &lsquo;<b>=</b>&rsquo; exp | Name &lsquo;<b>=</b>&rsquo; exp | exp
	fieldsep ::= &lsquo;<b>,</b>&rsquo; | &lsquo;<b>;</b>&rsquo;
</pre>

<p>
每个形如 <code>[exp1] = exp2</code> 的域向表中增加新的一项，
其键为 <code>exp1</code> 而值为 <code>exp2</code>。
形如 <code>name = exp</code> 的域等价于
<code>["name"] = exp</code>。
最后，形如 <code>exp</code> 的域等价于 <code>[i] = exp</code> ，
这里的 <code>i</code> 是一个从 1 开始不断增长的数字。
这这个格式中的其它域不会破坏其记数。
举个例子：

<pre>
     a = { [f(1)] = g; "x", "y"; x = 1, f(x), [30] = 23; 45 }
</pre><p>
等价于

<pre>
     do
       local t = {}
       t[f(1)] = g
       t[1] = "x"         -- 1st exp
       t[2] = "y"         -- 2nd exp
       t.x = 1            -- t["x"] = 1
       t[3] = f(x)        -- 3rd exp
       t[30] = 23
       t[4] = 45          -- 4th exp
       a = t
     end
</pre>

<p>
构造子中赋值的次序未定义。
（次序问题只会对那些键重复时的情况有影响。）


<p>
如果表单中最后一个域的形式是 <code>exp</code> ，
而且其表达式是一个函数调用或者是一个可变参数，
那么这个表达式所有的返回值将依次进入列表 
（参见 <a href="#3.4.10">&sect;3.4.10</a>）。


<p>
初始化域表可以在最后多一个分割符，
这样设计可以方便由机器生成代码。




<h3>3.4.10 &ndash; <a name="3.4.10">函数调用</a></h3><p>
Lua 中的函数调用的语法如下：

<pre>
	functioncall ::= prefixexp args
</pre><p>
函数调用时，
第一步，prefixexp 和 args 先被求值。
如果 prefixexp 的值的类型是 <em>function</em>，
那么这个函数就被用给出的参数调用。
否则 prefixexp 的元方法 "call" 就被调用，
第一个参数是 prefixexp 的值，
接下来的是原来的调用参数 
（参见 <a href="#2.4">&sect;2.4</a>）。


<p>
这样的形式

<pre>
	functioncall ::= prefixexp &lsquo;<b>:</b>&rsquo; Name args
</pre><p>
可以用来调用 "方法"。
这是 Lua 支持的一种语法糖。
像 <code>v:name(args)</code> 这个样子，
被解释成 <code>v.name(v,args)</code>，
这里的 <code>v</code> 只会被求值一次。


<p>
参数的语法如下：

<pre>
	args ::= &lsquo;<b>(</b>&rsquo; [explist] &lsquo;<b>)</b>&rsquo;
	args ::= tableconstructor
	args ::= LiteralString
</pre><p>
所有参数的表达式求值都在函数调用之前。
这样的调用形式 <code>f{fields}</code> 是一种语法糖用于表示
<code>f({fields})</code>；
这里指参数列表是一个新创建出来的列表。
而这样的形式 <code>f'<em>string</em>'</code>
（或是 <code>f"<em>string</em>"</code> 亦或是 <code>f[[<em>string</em>]]</code>）
也是一种语法糖，用于表示 <code>f('<em>string</em>')</code>；
此时的参数列表是一个单独的字符串。


<p>
<code>return <em>functioncall</em></code> 
这样的调用形式将触发一次 <em>尾调用</em>。
Lua 实现了 <em>完全尾调用</em>（或称为 <em>完全尾递归</em>）：
在尾调用中， 被调用的函数重用调用它的函数的堆栈项。
因此，对于程序执行的嵌套尾调用的层数是没有限制的。
然而，尾调用将删除调用它的函数的任何调试信息。
注意，尾调用只发生在特定的语法下，
仅当 <b>return</b> 只有单一函数调用作为参数时才发生尾调用；
这种语法使得调用函数的所有结果可以完整地返回。
因此，下面这些例子都不是尾调用：

<pre>
     return (f(x))        -- 返回值被调整为一个
     return 2 * f(x)
     return x, f(x)       -- 追加若干返回值
     f(x); return         -- 返回值全部被舍弃
     return x or f(x)     -- 返回值被调整为一个
</pre>




<h3>3.4.11 &ndash; <a name="3.4.11">函数定义</a></h3>

<p>
函数定义的语法如下：

<pre>
	functiondef ::= <b>function</b> funcbody
	funcbody ::= &lsquo;<b>(</b>&rsquo; [parlist] &lsquo;<b>)</b>&rsquo; block <b>end</b>
</pre>

<p>
另外定义了一些语法糖简化函数定义的写法：

<pre>
	stat ::= <b>function</b> funcname funcbody
	stat ::= <b>local</b> <b>function</b> Name funcbody
	funcname ::= Name {&lsquo;<b>.</b>&rsquo; Name} [&lsquo;<b>:</b>&rsquo; Name]
</pre><p>
该语句

<pre>
     function f () <em>body</em> end
</pre><p>
被转译成

<pre>
     f = function () <em>body</em> end
</pre><p>
该语句

<pre>
     function t.a.b.c.f () <em>body</em> end
</pre><p>
被转译成

<pre>
     t.a.b.c.f = function () <em>body</em> end
</pre><p>
该语句

<pre>
     local function f () <em>body</em> end
</pre><p>
被转译成

<pre>
     local f; f = function () <em>body</em> end
</pre><p>
而不是

<pre>
     local f = function () <em>body</em> end
</pre><p>
（这个差别只在函数体内需要引用 <code>f</code> 时才有。）


<p>
一个函数定义是一个可执行的表达式，
执行结果是一个类型为 <em>function</em> 的值。
当 Lua 预编译一个代码块时，
代码块作为一个函数，整个函数体也就被预编译了。
那么，无论何时 Lua 执行了函数定义，
这个函数本身就进行了 <em>实例化</em>（或者说是 <em>关闭</em>了）。
这个函数的实例（或者说是 <em>闭包</em>）是表达式的最终值。

<p>
形参被看作是一些局部变量，
它们将由实参的值来初始化：

<pre>
	parlist ::= namelist [&lsquo;<b>,</b>&rsquo; &lsquo;<b>...</b>&rsquo;] | &lsquo;<b>...</b>&rsquo;
</pre><p>
当一个函数被调用，
如果函数并非一个 <em>可变参数函数</em>，
即在形参列表的末尾注明三个点 ('<code>...</code>')，
那么实参列表就会被调整到形参列表的长度。
变长参数函数不会调整实参列表； 
取而代之的是，它将把所有额外的参数放在一起通过
<em>变长参数表达式</em>传递给函数，
其写法依旧是三个点。
这个表达式的值是一串实参值的列表，
看起来就跟一个可以返回多个结果的函数一样。
如果一个变长参数表达式放在另一个表达式中使用，
或是放在另一串表达式的中间，
那么它的返回值就会被调整为单个值。
若这个表达式放在了一系列表达式的最后一个，
就不会做调整了
（除非这最后一个参数被括号给括了起来）。


<p>
我们先做如下定义，然后再来看一个例子：

<pre>
     function f(a, b) end
     function g(a, b, ...) end
     function r() return 1,2,3 end
</pre><p>
下面看看实参到形参数以及可变长参数的映射关系：

<pre>
     CALL            PARAMETERS
     
     f(3)             a=3, b=nil
     f(3, 4)          a=3, b=4
     f(3, 4, 5)       a=3, b=4
     f(r(), 10)       a=1, b=10
     f(r())           a=1, b=2
     
     g(3)             a=3, b=nil, ... --&gt;  (nothing)
     g(3, 4)          a=3, b=4,   ... --&gt;  (nothing)
     g(3, 4, 5, 8)    a=3, b=4,   ... --&gt;  5  8
     g(5, r())        a=5, b=1,   ... --&gt;  2  3
</pre>

<p>
结果由 <b>return</b> 来返回（参见 <a href="#3.3.4">&sect;3.3.4</a>）。
如果执行到函数末尾依旧没有遇到任何 <b>return</b> 语句，
函数就不会返回任何结果。


<p>
关于函数可返回值的数量限制和系统有关。
这个限制一定大于 1000 。


<p>
<em>冒号</em> 语法可以用来定义 <em>方法</em>，
就是说，函数可以有一个隐式的形参 <code>self</code>。
因此，如下语句

<pre>
     function t.a.b.c:f (<em>params</em>) <em>body</em> end
</pre><p>
是这样一种写法的语法糖

<pre>
     t.a.b.c.f = function (self, <em>params</em>) <em>body</em> end
</pre>






<h2>3.5 &ndash; <a name="3.5">可见性规则</a></h2>

<p>
Lua 语言有词法作用范围。
变量的作用范围开始于声明它们之后的第一个语句段，
结束于包含这个声明的最内层语句块的最后一个非空语句。
看下面这些例子：

<pre>
     x = 10                -- 全局变量
     do                    -- 新的语句块
       local x = x         -- 新的一个 'x', 它的值现在是 10
       print(x)            --&gt; 10
       x = x+1
       do                  -- 另一个语句块
         local x = x+1     -- 又一个 'x'
         print(x)          --&gt; 12
       end
       print(x)            --&gt; 11
     end
     print(x)              --&gt; 10 （取到的是全局的那一个）
</pre>

<p>
注意这里，类似 <code>local x = x</code> 这样的声明，
新的 <code>x</code> 正在被声明，但是还没有进入它的作用范围，
所以第二个 <code>x</code> 指向的是外面一层的变量。


<p>
因为有这样一个词法作用范围的规则，
局部变量可以被在它的作用范围内定义的函数自由使用。
当一个局部变量被内层的函数中使用的时候，
它被内层函数称作 <em>上值</em>，或是 <em>外部局部变量</em>。


<p>
注意，每次执行到一个 <b>local</b> 语句都会定义出一个新的局部变量。
看看这样一个例子：

<pre>
     a = {}
     local x = 20
     for i=1,10 do
       local y = 0
       a[i] = function () y=y+1; return x+y end
     end
</pre><p>
这个循环创建了十个闭包（这指十个匿名函数的实例）。
这些闭包中的每一个都使用了不同的 <code>y</code> 变量，
而它们又共享了同一份 <code>x</code>。



<h1>6 &ndash; <a name="6">标准库</a></h1>

<p>
标准库提供了一些有用的函数,
它们都是直接用 C API 实现的。
其中一些函数提供了原本语言就有的服务
（例如，<a href="#pdf-type"><code>type</code></a> 与 <a href="#pdf-getmetatable"><code>getmetatable</code></a>）；
另一些提供和“外部”打交道的服务（例如 I/O ）；
还有些本可以用 Lua 本身来实现，但在 C 中实现可以满足关键点上的性能需求
（例如 <a href="#pdf-table.sort"><code>table.sort</code></a>）。

<p>
所有的库都是直接用 C API 实现的，并以分离的 C 模块形式提供。
目前，Lua 有下列标准库：

<ul>

<li>基础库 (<a href="#6.1">&sect;6.1</a>);</li>

<li>协程库 (<a href="#6.2">&sect;6.2</a>);</li>

<li>包管理库 (<a href="#6.3">&sect;6.3</a>);</li>

<li>字符串控制 (<a href="#6.4">&sect;6.4</a>);</li>

<li>基础 UTF-8 支持 (<a href="#6.5">&sect;6.5</a>);</li>

<li>表控制 (<a href="#6.6">&sect;6.6</a>);</li>

<li>数学函数 (<a href="#6.7">&sect;6.7</a>) (sin ，log 等);</li>

<li>输入输出 (<a href="#6.8">&sect;6.8</a>);</li>

<li>操作系统库 (<a href="#6.9">&sect;6.9</a>);</li>

<li>调试库 (<a href="#6.10">&sect;6.10</a>).</li>

</ul><p>
除了基础库和包管理库，
其它库都把自己的函数放在一张全局表的域中，
或是以对象方法的形式提供。


<p>
要使用这些库，
C 的宿主程序需要先调用一下
<a href="#luaL_openlibs"><code>luaL_openlibs</code></a> 这个函数，
这样就能打开所有的标准库。
或者宿主程序也可以用
<a href="#luaL_requiref"><code>luaL_requiref</code></a> 分别打开这些库：
<a name="pdf-luaopen_base"><code>luaopen_base</code></a> （基础库），
<a name="pdf-luaopen_package"><code>luaopen_package</code></a> （包管理库），
<a name="pdf-luaopen_coroutine"><code>luaopen_coroutine</code></a> （协程库），
<a name="pdf-luaopen_string"><code>luaopen_string</code></a> （字符串库），
<a name="pdf-luaopen_utf8"><code>luaopen_utf8</code></a> （UTF8 库），
<a name="pdf-luaopen_table"><code>luaopen_table</code></a> （表处理库），
<a name="pdf-luaopen_math"><code>luaopen_math</code></a> （数学库），
<a name="pdf-luaopen_io"><code>luaopen_io</code></a> （I/O 库），
<a name="pdf-luaopen_os"><code>luaopen_os</code></a> （操作系统库），
<a name="pdf-luaopen_debug"><code>luaopen_debug</code></a> （调试库）。
这些函数都定义在 <a name="pdf-lualib.h"><code>lualib.h</code></a> 中。



<h2>6.1 &ndash; <a name="6.1">基础函数</a></h2>

<p>
基础库提供了 Lua 核心函数。
如果你不将这个库包含在你的程序中，
你就需要小心检查程序是否需要自己提供其中一些特性的实现。

<p>
<hr><h3><a name="pdf-assert"><code>assert (v [, message])</code></a></h3>


<p>
如果其参数 <code>v</code> 的值为假（<b>nil</b> 或 <b>false</b>），
它就调用 <a href="#pdf-error"><code>error</code></a>；
否则，返回所有的参数。
在错误情况时，
<code>message</code> 指那个错误对象；
如果不提供这个参数，参数默认为 "<code>assertion failed!</code>" 。




<p>
<hr><h3><a name="pdf-collectgarbage"><code>collectgarbage ([opt [, arg]])</code></a></h3>


<p>
这个函数是垃圾收集器的通用接口。
通过参数 <code>opt</code> 它提供了一组不同的功能：

<ul>

<li><b>"<code>collect</code>": </b>
做一次完整的垃圾收集循环。
这是默认选项。
</li>

<li><b>"<code>stop</code>": </b>
停止垃圾收集器的运行。
在调用重启前，收集器只会因显式的调用运行。
</li>

<li><b>"<code>restart</code>": </b>
重启垃圾收集器的自动运行。
</li>

<li><b>"<code>count</code>": </b>
以 K 字节数为单位返回 Lua 使用的总内存数。
这个值有小数部分，所以只需要乘上 1024 就能得到
Lua 使用的准确字节数（除非溢出）。
</li>

<li><b>"<code>step</code>": </b>
单步运行垃圾收集器。
步长“大小”由 <code>arg</code> 控制。
传入 0 时，收集器步进（不可分割的）一步。
传入非 0 值，
收集器收集相当于 Lua 分配这些多（K 字节）内存的工作。
如果收集器结束一个循环将返回 <b>true</b> 。
</li>

<li><b>"<code>setpause</code>": </b>
将 <code>arg</code> 设为收集器的 <em>间歇率</em>
（参见 <a href="#2.5">&sect;2.5</a>）。
返回 <em>间歇率</em> 的前一个值。
</li>

<li><b>"<code>setstepmul</code>": </b>
将 <code>arg</code> 设为收集器的 <em>步进倍率</em>
（参见 <a href="#2.5">&sect;2.5</a>）。
返回 <em>步进倍率</em> 的前一个值。
</li>

<li><b>"<code>isrunning</code>": </b>
返回表示收集器是否在工作的布尔值
（即未被停止）。
</li>

</ul>



<p>
<hr><h3><a name="pdf-dofile"><code>dofile ([filename])</code></a></h3>
打开该名字的文件，并执行文件中的 Lua 代码块。
不带参数调用时， <code>dofile</code> 执行标准输入的内容（<code>stdin</code>）。
返回该代码块的所有返回值。
对于有错误的情况，<code>dofile</code> 将错误反馈给调用者
（即，<code>dofile</code> 没有运行在保护模式下）。




<p>
<hr><h3><a name="pdf-error"><code>error (message [, level])</code></a></h3>
中止上一次保护函数调用，
将错误对象 <code>message</code> 返回。
函数 <code>error</code> 永远不会返回。


<p>
当 message 是一个字符串时，通常 <code>error</code> 会把一些有关出错位置的信息附加在消息的前头。
<code>level</code> 参数指明了怎样获得出错位置。
对于 level 1 （默认值），出错位置指 <code>error</code> 函数调用的位置。
Level 2 将出错位置指向调用 <code>error</code>的函数的函数；以此类推。
传入 level 0 可以避免在消息前添加出错位置信息。




<p>
<hr><h3><a name="pdf-_G"><code>_G</code></a></h3>
一个全局变量（非函数），
内部储存有全局环境（参见 <a href="#2.2">&sect;2.2</a>）。
Lua 自己不使用这个变量；
改变这个变量的值不会对任何环境造成影响，反之亦然。




<p>
<hr><h3><a name="pdf-getmetatable"><code>getmetatable (object)</code></a></h3>


<p>
如果 <code>object</code> 不包含元表，返回 <b>nil</b> 。
否则，如果在该对象的元表中有 <code>"__metatable"</code> 域时返回其关联值，
没有时返回该对象的元表。



<p>
<hr><h3><a name="pdf-ipairs"><code>ipairs (t)</code></a></h3>


<p>
返回三个值（迭代函数、表 <code>t</code> 以及 0 ），
如此，以下代码

<pre>
     for i,v in ipairs(t) do <em>body</em> end
</pre><p>
将迭代键值对（<code>1,t[1]</code>) ，(<code>2,t[2]</code>)， ... ，直到第一个空值。



<p>
<hr><h3><a name="pdf-load"><code>load (chunk [, chunkname [, mode [, env]]])</code></a></h3>


<p>
加载一个代码块。


<p>
如果 <code>chunk</code> 是一个字符串，代码块指这个字符串。
如果 <code>chunk</code> 是一个函数，
<code>load</code> 不断地调用它获取代码块的片断。
每次对 <code>chunk</code> 的调用都必须返回一个字符串紧紧连接在上次调用的返回串之后。
当返回空串、<b>nil</b>、或是不返回值时，都表示代码块结束。


<p>
如果没有语法错误，
则以函数形式返回编译好的代码块；
否则，返回 <b>nil</b> 加上错误消息。


<p>
如果结果函数有上值，
<code>env</code> 被设为第一个上值。
若不提供此参数，将全局环境替代它。
所有其它上值初始化为 <b>nil</b>。
（当你加载主代码块时候，结果函数一定有且仅有一个上值 <code>_ENV</code> 
（参见 <a href="#2.2">&sect;2.2</a>））。
然而，如果你加载一个用函数（参见 <a href="#pdf-string.dump"><code>string.dump</code></a>，
结果函数可以有任意数量的上值）
创建出来的二进制代码块时，所有的上值都是新创建出来的。
也就是说它们不会和别的任何函数共享。


<p>
<code>chunkname</code> 在错误消息和调试消息中（参见 <a href="#4.9">&sect;4.9</a>），用于代码块的名字。
如果不提供此参数，它默认为字符串<code>chunk</code> 。
<code>chunk</code> 不是字符串时，则为 "<code>=(load)</code>" 。


<p>
字符串 <code>mode</code> 用于控制代码块是文本还是二进制（即预编译代码块）。
它可以是字符串 "<code>b</code>" （只能是二进制代码块），
"<code>t</code>" （只能是文本代码块），
或 "<code>bt</code>" （可以是二进制也可以是文本）。
默认值为 "<code>bt</code>"。


<p>
Lua 不会对二进制代码块做健壮性检查。
恶意构造一个二进制块有可能把解释器弄崩溃。



<p>
<hr><h3><a name="pdf-loadfile"><code>loadfile ([filename [, mode [, env]]])</code></a></h3>


<p>
和 <a href="#pdf-load"><code>load</code></a> 类似，
不过是从文件 <code>filename</code> 或标准输入（如果文件名未提供）中获取代码块。




<p>
<hr><h3><a name="pdf-next"><code>next (table [, index])</code></a></h3>


<p>
运行程序来遍历表中的所有域。
第一个参数是要遍历的表，第二个参数是表中的某个键。
<code>next</code> 返回该键的下一个键及其关联的值。
如果用 <b>nil</b> 作为第二个参数调用 <code>next</code>
将返回初始键及其关联值。
当以最后一个键去调用，或是以 <b>nil</b> 调用一张空表时，
<code>next</code> 返回 <b>nil</b>。
如果不提供第二个参数，将认为它就是 <b>nil</b>。
特别指出，你可以用 <code>next(t)</code> 来判断一张表是否是空的。


<p>
索引在遍历过程中的次序无定义，
<em>即使是数字索引也是这样</em>。
（如果想按数字次序遍历表，可以使用数字形式的 <b>for</b> 。）


<p>
当在遍历过程中你给表中并不存在的域赋值，
<code>next</code> 的行为是未定义的。
然而你可以去修改那些已存在的域。
特别指出，你可以清除一些已存在的域。



<p>
<hr><h3><a name="pdf-pairs"><code>pairs (t)</code></a></h3>


<p>
如果 <code>t</code> 有元方法 <code>__pairs</code>，
以 <code>t</code> 为参数调用它，并返回其返回的前三个值。


<p>
否则，返回三个值：<a href="#pdf-next"><code>next</code></a> 函数，
表 <code>t</code>，以及 <b>nil</b>。
因此以下代码

<pre>
     for k,v in pairs(t) do <em>body</em> end
</pre><p>
能迭代表 <code>t</code> 中的所有键值对。


<p>
参见函数 <a href="#pdf-next"><code>next</code></a> 中关于迭代过程中修改表的风险。




<p>
<hr><h3><a name="pdf-pcall"><code>pcall (f [, arg1, &middot;&middot;&middot;])</code></a></h3>


<p>
传入参数，以 <em>保护模式</em> 调用函数 <code>f</code> 。
这意味着 <code>f</code> 中的任何错误不会抛出；
取而代之的是，<code>pcall</code> 会将错误捕获到，并返回一个状态码。
第一个返回值是状态码（一个布尔量），
当没有错误时，其为真。
此时，<code>pcall</code> 同样会在状态码后返回所有调用的结果。
在有错误时，<code>pcall</code> 返回 <b>false</b> 加错误消息。




<p>
<hr><h3><a name="pdf-print"><code>print (&middot;&middot;&middot;)</code></a></h3>
接收任意数量的参数，并将它们的值打印到 <code>stdout</code>。
它用 <a href="#pdf-tostring"><code>tostring</code></a> 函数将每个参数都转换为字符串。
<code>print</code> 不用于做格式化输出。仅作为看一下某个值的快捷方式。
多用于调试。
完整的对输出的控制，请使用 <a href="#pdf-string.format"><code>string.format</code></a> 以及 <a href="#pdf-io.write"><code>io.write</code></a>。




<p>
<hr><h3><a name="pdf-rawequal"><code>rawequal (v1, v2)</code></a></h3>
在不触发任何元方法的情况下
检查 <code>v1</code> 是否和 <code>v2</code> 相等。
返回一个布尔量。



<p>
<hr><h3><a name="pdf-rawget"><code>rawget (table, index)</code></a></h3>
在不触发任何元方法的情况下
获取 <code>table[index]</code> 的值。
<code>table</code> 必须是一张表；
<code>index</code> 可以是任何值。




<p>
<hr><h3><a name="pdf-rawlen"><code>rawlen (v)</code></a></h3>
在不触发任何元方法的情况下
返回对象 <code>v</code> 的长度。
<code>v</code> 可以是表或字符串。
它返回一个整数。


<p>
<hr><h3><a name="pdf-rawset"><code>rawset (table, index, value)</code></a></h3>
在不触发任何元方法的情况下
将 <code>table[index]</code> 设为 <code>value</code>。
<code>table</code> 必须是一张表，
<code>index</code> 可以是 <b>nil</b> 与 NaN 之外的任何值。
<code>value</code> 可以是任何 Lua 值。


<p>
这个函数返回 <code>table</code>。




<p>
<hr><h3><a name="pdf-select"><code>select (index, &middot;&middot;&middot;)</code></a></h3>


<p>
如果 <code>index</code> 是个数字，
那么返回参数中第 <code>index</code> 个之后的部分；
负的数字会从后向前索引（-1 指最后一个参数）。
否则，<code>index</code> 必须是字符串 <code>"#"</code>，
此时 <code>select</code> 返回参数的个数。




<p>
<hr><h3><a name="pdf-setmetatable"><code>setmetatable (table, metatable)</code></a></h3>


<p>
给指定表设置元表。
（你不能在 Lua 中改变其它类型值的元表，那些只能在 C 里做。）
如果 <code>metatable</code> 是 <b>nil</b>，
将指定表的元表移除。
如果原来那张元表有 <code>"__metatable"</code> 域，抛出一个错误。


<p>
这个函数返回 <code>table</code>。




<p>
<hr><h3><a name="pdf-tonumber"><code>tonumber (e [, base])</code></a></h3>


<p>
如果调用的时候没有 <code>base</code>，
<code>tonumber</code> 尝试把参数转换为一个数字。
如果参数已经是一个数字，或是一个可以转换为数字的字符串，
<code>tonumber</code> 就返回这个数字；
否则返回 <b>nil</b>。


<p>
字符串的转换结果可能是整数也可能是浮点数，
这取决于 Lua 的转换文法（参见 <a href="#3.1">&sect;3.1</a>）。
（字符串可以有前置和后置的空格，可以带符号。）


<p>
当传入 <code>base</code> 调用它时，
<code>e</code> 必须是一个以该进制表示的整数字符串。
进制可以是 2 到 36 （包含 2 和 36）之间的任何整数。
大于 10 进制时，字母 '<code>A</code>' （大小写均可）表示 10 ，
'<code>B</code>' 表示 11，依次到 '<code>Z</code>' 表示 35 。
如果字符串 <code>e</code> 不是该进制下的合法数字，
函数返回 <b>nil</b>。




<p>
<hr><h3><a name="pdf-tostring"><code>tostring (v)</code></a></h3>
可以接收任何类型，它将其转换为人可阅读的字符串形式。
浮点数总被转换为浮点数的表现形式（小数点形式或是指数形式）。
（如果想完全控制数字如何被转换，可以使用
<a href="#pdf-string.format"><code>string.format</code></a>。）


<p>
如果 <code>v</code> 有 <code>"__tostring"</code> 域的元表，
<code>tostring</code> 会以 <code>v</code> 为参数调用它。
并用它的结果作为返回值。



<p>
<hr><h3><a name="pdf-type"><code>type (v)</code></a></h3>
将参数的类型编码为一个字符串返回。
函数可能的返回值有
"<code>nil</code>" （一个字符串，而不是 <b>nil</b> 值），
"<code>number</code>"，
"<code>string</code>"，
"<code>boolean</code>"，
"<code>table</code>"，
"<code>function</code>"，
"<code>thread</code>"，
"<code>userdata</code>"。




<p>
<hr><h3><a name="pdf-_VERSION"><code>_VERSION</code></a></h3>
一个包含有当前解释器版本号的全局变量（并非函数）。
当前这个变量的值为 "<code>Lua 5.3</code>"。




<p>
<hr><h3><a name="pdf-xpcall"><code>xpcall (f, msgh [, arg1, &middot;&middot;&middot;])</code></a></h3>


<p>
这个函数和 <a href="#pdf-pcall"><code>pcall</code></a> 类似。
不过它可以额外设置一个消息处理器 <code>msgh</code>。


<h2>6.3 &ndash; <a name="6.3">模块</a></h2>

<p>
包管理库提供了从 Lua 中加载模块的基础库。
只有一个导出函数直接放在全局环境中：
<a href="#pdf-require"><code>require</code></a>。
所有其它的部分都导出在表 <a name="pdf-package"><code>package</code></a> 中。


<p>
<hr><h3><a name="pdf-require"><code>require (modname)</code></a></h3>


<p>
加载一个模块。
这个函数首先查找 <a href="#pdf-package.loaded"><code>package.loaded</code></a> 表，
检测 <code>modname</code> 是否被加载过。
如果被加载过，<code>require</code> 返回 <code>package.loaded[modname]</code> 中保存的值。
否则，它试着为模块寻找 <em>加载器</em> 。


<p>

<code>require</code> 遵循 <a href="#pdf-package.searchers"><code>package.searchers</code></a> 序列的指引来查找加载器。
如果改变这个序列，我们可以改变 <code>require</code> 如何查找一个模块。
下列说明基于 <a href="#pdf-package.searchers"><code>package.searchers</code></a>
的默认配置。


<p>
首先 <code>require</code> 查找 <code>package.preload[modname]</code> 。
如果这里有一个值，这个值（必须是一个函数）就是那个加载器。
否则 <code>require</code> 使用 Lua 加载器去查找
<a href="#pdf-package.path"><code>package.path</code></a> 的路径。
如果查找失败，接着使用 C 加载器去查找
<a href="#pdf-package.cpath"><code>package.cpath</code></a> 的路径。
如果都失败了，再尝试 <em>一体化</em> 加载器 （参见 <a href="#pdf-package.searchers"><code>package.searchers</code></a>）。


<p>
每次找到一个加载器，<code>require</code> 都用两个参数调用加载器：
<code>modname</code> 和一个在获取加载器过程中得到的参数。
（如果通过查找文件得到的加载器，这个额外参数是文件名。）
如果加载器返回非空值，
<code>require</code> 将这个值赋给 <code>package.loaded[modname]</code>。
如果加载器没能返回一个非空值用于赋给 <code>package.loaded[modname]</code>，
<code>require</code> 会在那里设入 <b>true</b> 。
无论是什么情况，<code>require</code> 都会返回
<code>package.loaded[modname]</code> 的最终值。


<p>
如果在加载或运行模块时有错误，
或是无法为模块找到加载器，
<code>require</code> 都会抛出错误。




<p>
<hr><h3><a name="pdf-package.config"><code>package.config</code></a></h3>


<p>
一个描述有一些为包管理准备的编译期配置信息的串。
这个字符串由一系列行构成：

<ul>

<li>第一行是目录分割串。
对于 Windows 默认是 '<code>\</code>' ，对于其它系统是 '<code>/</code>' 。</li>

<li>第二行是用于路径中的分割符。默认值是 '<code>;</code>' 。</li>

<li>第三行是用于标记模板替换点的字符串。
默认是 '<code>?</code>' 。</li>

<li>第四行是在 Windows 中将被替换成执行程序所在目录的路径的字符串。
默认是 '<code>!</code>' 。</li>

<li>第五行是一个记号，该记号之后的所有文本将在构建 <code>luaopen_</code> 函数名时被忽略掉。
默认是 '<code>-</code>'。</li>

</ul>



<p>
<hr><h3><a name="pdf-package.cpath"><code>package.cpath</code></a></h3>


<p>
这个路径被 <a href="#pdf-require"><code>require</code></a> 在 C 加载器中做搜索时用到。


<p>
Lua 用和初始化 Lua 路径 <a href="#pdf-package.path"><code>package.path</code></a>
相同的方式初始化 C 路径 <a href="#pdf-package.cpath"><code>package.cpath</code></a> 。
它会使用环境变量 <a name="pdf-LUA_CPATH_5_3"><code>LUA_CPATH_5_3</code></a> 或
环境变量 <a name="pdf-LUA_CPATH"><code>LUA_CPATH</code></a> 初始化。
要么就采用 <code>luaconf.h</code> 中定义的默认路径。



<p>
<hr><h3><a name="pdf-package.loaded"><code>package.loaded</code></a></h3>


<p>
用于 <a href="#pdf-require"><code>require</code></a> 控制哪些模块已经被加载的表。
当你请求一个 <code>modname</code> 模块，且
<code>package.loaded[modname]</code> 不为假时，
<a href="#pdf-require"><code>require</code></a> 简单返回储存在内的值。


<p>
这个变量仅仅是对真正那张表的引用；
改变这个值并不会改变 <a href="#pdf-require"><code>require</code></a> 使用的表。




<p>
<hr><h3><a name="pdf-package.loadlib"><code>package.loadlib (libname, funcname)</code></a></h3>


<p>
让宿主程序动态链接 C 库 <code>libname</code> 。


<p>
当 <code>funcname</code> 为 "<code>*</code>"，
它仅仅连接该库，让库中的符号都导出给其它动态链接库使用。
否则，它查找库中的函数 <code>funcname</code> ，以 C 函数的形式返回这个函数。
因此，<code>funcname</code> 必须遵循原型 <a href="#lua_CFunction"><code>lua_CFunction</code></a> 
（参见 <a href="#lua_CFunction"><code>lua_CFunction</code></a>）。


<p>
这是一个低阶函数。
它完全绕过了包模块系统。
和 <a href="#pdf-require"><code>require</code></a> 不同，
它不会做任何路径查询，也不会自动加扩展名。
<code>libname</code> 必须是一个 C 库需要的完整的文件名，如果有必要，需要提供路径和扩展名。
<code>funcname</code> 必须是 C 库需要的准确名字
（这取决于使用的 C 编译器和链接器）。


<p>
这个函数在标准 C 中不支持。
因此，它只在部分平台有效
（ Windows ，Linux ，Mac OS X, Solaris, BSD, 加上支持
<code>dlfcn</code> 标准的 Unix 系统）。




<p>
<hr><h3><a name="pdf-package.path"><code>package.path</code></a></h3>


<p>
这个路径被 <a href="#pdf-require"><code>require</code></a> 在 Lua 加载器中做搜索时用到。


<p>
在启动时，Lua 用环境变量 <a name="pdf-LUA_PATH_5_3"><code>LUA_PATH_5_3</code></a>
或环境变量 <a name="pdf-LUA_PATH"><code>LUA_PATH</code></a> 来初始化这个变量。
或采用 <code>luaconf.h</code> 中的默认路径。
环境变量中出现的所有 "<code>;;</code>" 都会被替换成默认路径。




<p>
<hr><h3><a name="pdf-package.preload"><code>package.preload</code></a></h3>


<p>
保存有一些特殊模块的加载器
（参见 <a href="#pdf-require"><code>require</code></a>）。


<p>
这个变量仅仅是对真正那张表的引用；
改变这个值并不会改变 <a href="#pdf-require"><code>require</code></a> 使用的表。




<p>
<hr><h3><a name="pdf-package.searchers"><code>package.searchers</code></a></h3>


<p>
用于 <a href="#pdf-require"><code>require</code></a> 控制如何加载模块的表。


<p>
这张表内的每一项都是一个 <em>查找器函数</em>。
当查找一个模块时，
<a href="#pdf-require"><code>require</code></a> 按次序调用这些查找器，
并传入模块名（<a href="#pdf-require"><code>require</code></a> 的参数）作为唯一的一个参数。
此函数可以返回另一个函数（模块的 <em>加载器</em>）加上另一个将传递给这个加载器的参数。
或是返回一个描述为何没有找到这个模块的字符串
（或是返回 <b>nil</b> 什么也不想说）。


<p>
Lua 用四个查找器函数初始化这张表。


<p>
第一个查找器就是简单的在 <a href="#pdf-package.preload"><code>package.preload</code></a> 表中查找加载器。


<p>
第二个查找器用于查找 Lua 库的加载库。
它使用储存在 <a href="#pdf-package.path"><code>package.path</code></a> 中的路径来做查找工作。
查找过程和函数 <a href="#pdf-package.searchpath"><code>package.searchpath</code></a> 描述的一致。


<p>
第三个查找器用于查找 C 库的加载库。
它使用储存在 <a href="#pdf-package.path"><code>package.cpath</code></a> 中的路径来做查找工作。
同样，
查找过程和函数 <a href="#pdf-package.searchpath"><code>package.searchpath</code></a> 描述的一致。
例如，如果 C 路径是这样一个字符串

<pre>
     "./?.so;./?.dll;/usr/local/?/init.so"
</pre><p>
查找器查找模块 <code>foo</code> 
会依次尝试打开文件 <code>./foo.so</code>，<code>./foo.dll</code>，
以及 <code>/usr/local/foo/init.so</code>。
一旦它找到一个 C 库，
查找器首先使用动态链接机制连接该库。
然后尝试在该库中找到可以用作加载器的 C 函数。
这个 C 函数的名字是 "<code>luaopen_</code>" 紧接模块名的字符串，
其中字符串中所有的下划线都会被替换成点。
此外，如果模块名中有横线，
横线后面的部分（包括横线）都被去掉。
例如，如果模块名为 <code>a.b.c-v2.1</code>，
函数名就是 <code>luaopen_a_b_c</code>。


<p>
第四个搜索器是　<em>一体化加载器</em>。
它从 C 路径中查找指定模块的根名字。
例如，当请求 <code>a.b.c</code>　时，
它将查找 <code>a</code> 这个 C 库。
如果找得到，它会在里面找子模块的加载函数。
在我们的例子中，就是找　<code>luaopen_a_b_c</code>。
利用这个机制，可以把若干 C 子模块打包进单个库。
每个子模块都可以有原本的加载函数名。


<p>
除了第一个（预加载）搜索器外，每个搜索器都会返回
它找到的模块的文件名。
这和 <a href="#pdf-package.searchpath"><code>package.searchpath</code></a> 的返回值一样。
第一个搜索器没有返回值。



<p>
<hr><h3><a name="pdf-package.searchpath"><code>package.searchpath (name, path [, sep [, rep]])</code></a></h3>


<p>
在指定 <code>path</code> 中搜索指定的 <code>name</code> 。


<p>
路径是一个包含有一系列以分号分割的 <em>模板</em> 构成的字符串。
对于每个模板，都会用 <code>name</code> 替换其中的每个问号（如果有的话）。
且将其中的 <code>sep</code> （默认是点）替换为  <code>rep</code>
（默认是系统的目录分割符）。
然后尝试打开这个文件名。


<p>
例如，如果路径是字符串

<pre>
     "./?.lua;./?.lc;/usr/local/?/init.lua"
</pre><p>
搜索 <code>foo.a</code>　这个名字将
依次尝试打开文件
<code>./foo/a.lua</code>　， <code>./foo/a.lc</code>　，以及
<code>/usr/local/foo/a/init.lua</code>。


<p>
返回第一个可以用读模式打开（并马上关闭该文件）的文件的名字。
如果不存在这样的文件，返回 <b>nil</b> 加上错误消息。
（这条错误消息列出了所有尝试打开的文件名。）






<h2>6.4 &ndash; <a name="6.4">字符串处理</a></h2>

<p>
这个库提供了字符串处理的通用函数。
例如字符串查找、子串、模式匹配等。
当在 Lua 中对字符串做索引时，第一个字符从 1 开始计算（而不是 C 里的 0 ）。
索引可以是负数，它指从字符串末尾反向解析。
即，最后一个字符在 -1 位置处，等等。


<p>
字符串库中的所有函数都在表 <a name="pdf-string"><code>string</code></a> 中。
它还将其设置为字符串元表的 <code>__index</code> 域。
因此，你可以以面向对象的形式使用字符串函数。
例如，<code>string.byte(s,i)</code> 可以写成 <code>s:byte(i)</code>。


<p>
字符串库假定采用单字节字符编码。


<p>
<hr><h3><a name="pdf-string.byte"><code>string.byte (s [, i [, j]])</code></a></h3>
返回字符 <code>s[i]</code>，
<code>s[i+1]</code>， ...　，<code>s[j]</code>
的内部数字编码。
<code>i</code> 的默认值是 1 ；
<code>j</code> 的默认值是 <code>i</code>。
这些索引以函数 <a href="#pdf-string.sub"><code>string.sub</code></a> 的规则修正。


<p>
数字编码没有必要跨平台。




<p>
<hr><h3><a name="pdf-string.char"><code>string.char (&middot;&middot;&middot;)</code></a></h3>
接收零或更多的整数。
返回和参数数量相同长度的字符串。
其中每个字符的内部编码值等于对应的参数值。

<p>
数字编码没有必要跨平台。



<p>
<hr><h3><a name="pdf-string.dump"><code>string.dump (function [, strip])</code></a></h3>


<p>
返回包含有以二进制方式表示的（一个 <em>二进制代码块</em> ）指定函数的字符串。
之后可以用 <a href="#pdf-load"><code>load</code></a> 调用这个字符串获得
该函数的副本（但是绑定新的上值）。
如果　<code>strip</code> 为真值，
二进制代码块不携带该函数的调试信息
（局部变量名，行号，等等。）。


<p>
带上值的函数只保存上值的数目。
当（再次）加载时，这些上值被更新为 <b>nil</b> 的实例。
（你可以使用调试库按你需要的方式来序列化上值，并重载到函数中）



<p>
<hr><h3><a name="pdf-string.find"><code>string.find (s, pattern [, init [, plain]])</code></a></h3>


<p>
查找第一个字符串 <code>s</code> 中匹配到的 <code>pattern</code>
（参见 <a href="#6.4.1">&sect;6.4.1</a>）。
如果找到一个匹配，<code>find</code> 会返回 <code>s</code>
中关于它起始及终点位置的索引；
否则，返回 <b>nil</b>。
第三个可选数字参数 <code>init</code>
指明从哪里开始搜索；
默认值为 1 ，同时可以是负值。
第四个可选参数 <code>plain</code> 为 <b>true</b> 时，
关闭模式匹配机制。
此时函数仅做直接的 “查找子串”的操作，
而 <code>pattern</code> 中没有字符被看作魔法字符。
注意，如果给定了 <code>plain</code>　，就必须写上 <code>init</code> 。


<p>
如果在模式中定义了捕获，捕获到的若干值也会在两个索引之后返回。



<p>
<hr><h3><a name="pdf-string.format"><code>string.format (formatstring, &middot;&middot;&middot;)</code></a></h3>


<p>
返回不定数量参数的格式化版本，
格式化串为第一个参数（必须是一个字符串）。
格式化字符串遵循 ISO C 函数 <code>sprintf</code> 的规则。
不同点在于选项
<code>*</code>, <code>h</code>, <code>L</code>, <code>l</code>, <code>n</code>,
<code>p</code> 不支持，
另外还增加了一个选项 <code>q</code>。
<code>q</code> 选项将一个字符串格式化为两个双引号括起，对内部字符做恰当的转义处理的字符串。
该字符串可以安全的被 Lua 解释器读回来。
例如，调用

<pre>
     string.format('%q', 'a string with "quotes" and \n new line')
</pre><p>
会产生字符串：

<pre>
     "a string with \"quotes\" and \
      new line"
</pre>

<p>
选项
<code>A</code> and <code>a</code> （如果有的话），
<code>E</code>, <code>e</code>, <code>f</code>,
<code>G</code>, and <code>g</code> 都期待一个对应的数字参数。
选项 <code>c</code>, <code>d</code>,
<code>i</code>, <code>o</code>, <code>u</code>, <code>X</code>, and <code>x</code>
则期待一个整数。
选项 <code>q</code> 期待一个字符串；
选项 <code>s</code> 期待一个没有内嵌零的字符串。
如果选项 <code>s</code> 对应的参数不是字符串，它会用和
<a href="#pdf-tostring"><code>tostring</code></a> 一致的规则转换成字符串。



<p>
<hr><h3><a name="pdf-string.gmatch"><code>string.gmatch (s, pattern)</code></a></h3>
返回一个迭代器函数。
每次调用这个函数都会继续以 <code>pattern</code> （参见　<a href="#6.4.1">&sect;6.4.1</a>）
对 <code>s</code> 做匹配，并返回所有捕获到的值。
如果 <code>pattern</code> 中没有指定捕获，则每次捕获整个 <code>pattern</code>。


<p>
下面这个例子会循环迭代字符串 <code>s</code> 中所有的单词，
并逐行打印：

<pre>
     s = "hello world from Lua"
     for w in string.gmatch(s, "%a+") do
       print(w)
     end
</pre><p>
下一个例子从指定的字符串中收集所有的键值对
<code>key=value</code>
置入一张表：

<pre>
     t = {}
     s = "from=world, to=Lua"
     for k, v in string.gmatch(s, "(%w+)=(%w+)") do
       t[k] = v
     end
</pre>

<p>
对这个函数来说，模板前开始的 '<code>^</code>' 不会当成锚点。因为这样会阻止迭代。



<p>
<hr><h3><a name="pdf-string.gsub"><code>string.gsub (s, pattern, repl [, n])</code></a></h3>
将字符串 <code>s</code> 中，所有的（或是在 <code>n</code> 给出时的前 <code>n</code> 个）
<code>pattern</code> （参见
 <a href="#6.4.1">&sect;6.4.1</a>）都替换成 <code>repl</code> ，并返回其副本。
<code>repl</code> 可以是字符串、表、或函数。
<code>gsub</code> 还会在第二个返回值返回一共发生了多少次匹配。
<code>gsub</code> 这个名字来源于 <em>Global SUBstitution</em> 。


<p>
如果 <code>repl</code> 是一个字符串，那么把这个字符串作为替换品。
字符 <code>%</code> 是一个转义符：
<code>repl</code> 中的所有形式为 <code>%<em>d</em></code> 的串表示
第 <em>d</em> 个捕获到的子串，<em>d</em> 可以是 1 到 9 。
串 <code>%0</code> 表示整个匹配。
串 <code>%%</code> 表示单个 <code>%</code>。


<p>
如果 <code>repl</code> 是张表，每次匹配时都会用第一个捕获物作为键去查这张表。


<p>
如果 <code>repl</code> 是个函数，则在每次匹配发生时都会调用这个函数。
所有捕获到的子串依次作为参数传入。


<p>
任何情况下，模板中没有设定捕获都看成是捕获整个模板。


<p>
如果表的查询结果或函数的返回结果是一个字符串或是个数字，
都将其作为替换用串；
而在返回 <b>false</b> 或 <b>nil</b>　时不作替换
（即保留匹配前的原始串）。


<p>
这里有一些用例：

<pre>
     x = string.gsub("hello world", "(%w+)", "%1 %1")
     --&gt; x="hello hello world world"
     
     x = string.gsub("hello world", "%w+", "%0 %0", 1)
     --&gt; x="hello hello world"
     
     x = string.gsub("hello world from Lua", "(%w+)%s*(%w+)", "%2 %1")
     --&gt; x="world hello Lua from"
     
     x = string.gsub("home = $HOME, user = $USER", "%$(%w+)", os.getenv)
     --&gt; x="home = /home/roberto, user = roberto"
     
     x = string.gsub("4+5 = $return 4+5$", "%$(.-)%$", function (s)
           return load(s)()
         end)
     --&gt; x="4+5 = 9"
     
     local t = {name="lua", version="5.3"}
     x = string.gsub("$name-$version.tar.gz", "%$(%w+)", t)
     --&gt; x="lua-5.3.tar.gz"
</pre>



<p>
<hr><h3><a name="pdf-string.len"><code>string.len (s)</code></a></h3>
接收一个字符串，返回其长度。
空串 <code>""</code> 的长度为 0 。
内嵌零也统计在内，因此
<code>"a\000bc\000"</code> 的长度为 5 。




<p>
<hr><h3><a name="pdf-string.lower"><code>string.lower (s)</code></a></h3>
接收一个字符串，将其中的大写字符都转为小写后返回其副本。
其它的字符串不会更改。
对大写字符的定义取决于当前的区域设置。



<p>
<hr><h3><a name="pdf-string.match"><code>string.match (s, pattern [, init])</code></a></h3>
在字符串 <code>s</code> 中找到第一个能用 <code>pattern</code>
（参见 <a href="#6.4.1">&sect;6.4.1</a>）匹配到的部分。
如果能找到，<code>match</code> 返回其中的捕获物；
否则返回 <b>nil</b> 。
如果 <code>pattern</code> 中未指定捕获，
返回整个 <code>pattern</code> 捕获到的串。
第三个可选数字参数 <code>init</code>
指明从哪里开始搜索；
它默认为 1 且可以是负数。



<p>
<hr><h3><a name="pdf-string.pack"><code>string.pack (fmt, v1, v2, &middot;&middot;&middot;)</code></a></h3>


<p>
返回一个打包了（即以二进制形式序列化） <code>v1</code>, <code>v2</code> 等值的二进制字符串。
字符串 <code>fmt</code> 为打包格式（参见 <a href="#6.4.2">&sect;6.4.2</a>）。




<p>
<hr><h3><a name="pdf-string.packsize"><code>string.packsize (fmt)</code></a></h3>


<p>
返回以指定格式用 <a href="#pdf-string.pack"><code>string.pack</code></a>
打包的字符串的长度。
格式化字符串中不可以有变长选项 '<code>s</code>' 或 '<code>z</code>'
（参见 <a href="#6.4.2">&sect;6.4.2</a>）。




<p>
<hr><h3><a name="pdf-string.rep"><code>string.rep (s, n [, sep])</code></a></h3>
返回 <code>n</code> 个字符串 <code>s</code> 以字符串 <code>sep</code>
为分割符连在一起的字符串。
默认的 <code>sep</code> 值为空字符串（即没有分割符）。
如果 <code>n</code> 不是正数则返回空串。



<p>
<hr><h3><a name="pdf-string.reverse"><code>string.reverse (s)</code></a></h3>
返回字符串 <code>s</code> 的翻转串。




<p>
<hr><h3><a name="pdf-string.sub"><code>string.sub (s, i [, j])</code></a></h3>
返回 <code>s</code> 的子串，
该子串从 <code>i</code> 开始到 <code>j</code> 为止；
<code>i</code> 和 <code>j</code> 都可以为负数。
如果不给出 <code>j</code> ，就当它是 -1 
（和字符串长度相同）。
特别是，
调用 <code>string.sub(s,1,j)</code> 可以返回 <code>s</code>
的长度为 <code>j</code> 的前缀串，
而 <code>string.sub(s, -i)</code> 返回长度为 <code>i</code>
的后缀串。


<p>
如果在对负数索引转义后 <code>i</code> 小于 1 的话，就修正回 1 。
如果 <code>j</code> 比字符串的长度还大，就修正为字符串长度。
如果在修正之后，<code>i</code> 大于 <code>j</code>，
函数返回空串。



<p>
<hr><h3><a name="pdf-string.unpack"><code>string.unpack (fmt, s [, pos])</code></a></h3>


<p>
返回以格式 <code>fmt</code> （参见 <a href="#6.4.2">&sect;6.4.2</a>）
打包在字符串 <code>s</code> （参见 <a href="#pdf-string.pack"><code>string.pack</code></a>）
中的值。
选项 <code>pos</code>（默认为 1 ）标记了从 <code>s</code>
中哪里开始读起。
读完所有的值后，函数返回 <code>s</code> 中第一个未读字节的位置。



<p>
<hr><h3><a name="pdf-string.upper"><code>string.upper (s)</code></a></h3>
接收一个字符串，将其中的小写字符都转为大写后返回其副本。
其它的字符串不会更改。
对小写字符的定义取决于当前的区域设置。




<h3>6.4.1 &ndash; <a name="6.4.1">匹配模式</a></h3>

<p>
Lua 中的匹配模式直接用常规的字符串来描述。
它用于模式匹配函数
<a href="#pdf-string.find"><code>string.find</code></a>,
<a href="#pdf-string.gmatch"><code>string.gmatch</code></a>,
<a href="#pdf-string.gsub"><code>string.gsub</code></a>,
<a href="#pdf-string.match"><code>string.match</code></a>。
这一节表述了这些字符串的语法及含义（即它能匹配到什么）。



<h4>字符类：</h4><p>
<em>字符类</em> 用于表示一个字符集合。
下列组合可用于字符类：

<ul>

<li><b><em>x</em>: </b>
（这里 <em>x</em> 不能是 <em>魔法字符</em> <code>^$()%.[]*+-?</code> 中的一员）
表示字符 <em>x</em> 自身。
</li>

<li><b><code>.</code>: </b> （一个点）可表示任何字符。</li>

<li><b><code>%a</code>: </b> 表示任何字母。</li>

<li><b><code>%c</code>: </b> 表示任何控制字符。</li>

<li><b><code>%d</code>: </b> 表示任何数字。</li>

<li><b><code>%g</code>: </b> 表示任何除空白符外的可打印字符。</li>

<li><b><code>%l</code>: </b> 表示所有小写字母。</li>

<li><b><code>%p</code>: </b> 表示所有标点符号。</li>

<li><b><code>%s</code>: </b> 表示所有空白字符。</li>

<li><b><code>%u</code>: </b> 表示所有大写字母。</li>

<li><b><code>%w</code>: </b> 表示所有字母及数字。</li>

<li><b><code>%x</code>: </b> 表示所有 16 进制数字符号。</li>

<li><b><code>%<em>x</em></code>: </b> 
（这里的 <em>x</em> 是任意非字母或数字的字符）
表示字符 <em>x</em>。
这是对魔法字符转义的标准方法。
所有非字母或数字的字符
（包括所有标点，也包括非魔法字符）
都可以用前置一个 '<code>%</code>' 放在模式串中表示自身。
</li>

<li><b><code>[<em>set</em>]</code>: </b>
表示 <em>set</em>　中所有字符的联合。
可以以 '<code>-</code>' 连接，升序书写范围两端的字符来表示一个范围的字符集。
上面提到的 <code>%</code><em>x</em> 形式也可以在 <em>set</em> 中使用
表示其中的一个元素。
其它出现在 <em>set</em> 中的字符则代表它们自己。
例如，<code>[%w_]</code> （或 <code>[_%w]</code>）
表示所有的字母数字加下划线），
<code>[0-7]</code> 表示 8 进制数字，
<code>[0-7%l%-]</code>　表示 8 进制数字加小写字母与 '<code>-</code>' 字符。


<p>
交叉使用类和范围的行为未定义。
因此，像 <code>[%a-z]</code> 或 <code>[a-%%]</code>
这样的模式串没有意义。
</li>

<li><b><code>[^<em>set</em>]</code>: </b>
表示 <em>set</em> 的补集，
其中 <em>set</em> 如上面的解释。
</li>

</ul><p>
所有单个字母表示的类别（<code>%a</code>，<code>%c</code>，等），
若将其字母改为大写，均表示对应的补集。
例如，<code>%S</code> 表示所有非空格的字符。


<p>
如何定义字母、空格、或是其他字符组取决于当前的区域设置。
特别注意：<code>[a-z]</code>　未必等价于 <code>%l</code> 。




<h4>模式条目：</h4><p>
<em>模式条目</em> 可以是

<ul>

<li>
单个字符类匹配该类别中任意单个字符；
</li>

<li>
单个字符类跟一个 '<code>*</code>'，
将匹配零或多个该类的字符。
这个条目总是匹配尽可能长的串；
</li>

<li>
单个字符类跟一个 '<code>+</code>'，
将匹配一或更多个该类的字符。
这个条目总是匹配尽可能长的串；
</li>

<li>
单个字符类跟一个 '<code>-</code>'，
将匹配零或更多个该类的字符。
和 '<code>*</code>' 不同，
这个条目总是匹配尽可能短的串；
</li>

<li>
单个字符类跟一个 '<code>?</code>'，
将匹配零或一个该类的字符。
只要有可能，它会匹配一个；
</li>

<li>
<code>%<em>n</em></code>，
这里的 <em>n</em> 可以从 1 到 9；
这个条目匹配一个等于 <em>n</em> 号捕获物（后面有描述）的子串。
</li>

<li>
<code>%b<em>xy</em></code>，
这里的 <em>x</em> 和 <em>y</em> 是两个明确的字符；
这个条目匹配以 <em>x</em> 开始 <em>y</em> 结束，
且其中 <em>x</em> 和 <em>y</em> 保持 <em>平衡</em> 的字符串。
意思是，如果从左到右读这个字符串，对每次读到一个
<em>x</em> 就 <em>+1</em> ，读到一个 <em>y</em> 就 <em>-1</em>，
最终结束处的那个 <em>y</em> 是第一个记数到 0 的 <em>y</em>。
举个例子，条目 <code>%b()</code> 可以匹配到括号平衡的表达式。
</li>

<li>
<code>%f[<em>set</em>]</code>，
指 <em>边境模式</em>；
这个条目会匹配到一个位于 <em>set</em> 内某个字符之前的一个空串，
且这个位置的前一个字符不属于 <em>set</em> 。
集合 <em>set</em> 的含义如前面所述。
匹配出的那个空串之开始和结束点的计算就看成该处有个字符
'<code>\0</code>' 一样。
</li>

</ul>




<h4>模式：</h4><p>
<em>模式</em> 指一个模式条目的序列。
在模式最前面加上符号 '<code>^</code>' 将锚定从字符串的开始处做匹配。
在模式最后面加上符号 '<code>$</code>' 将使匹配过程锚定到字符串的结尾。
如果 '<code>^</code>' 和 '<code>$</code>' 出现在其它位置，它们均没有特殊含义，只表示自身。





<h4>捕获：</h4><p>
模式可以在内部用小括号括起一个子模式；
这些子模式被称为 <em>捕获物</em>。
当匹配成功时，由 <em>捕获物</em> 匹配到的字符串中的子串被保存起来用于未来的用途。
捕获物以它们左括号的次序来编号。
例如，对于模式 <code>"(a*(.)%w(%s*))"</code> ，
字符串中匹配到 <code>"a*(.)%w(%s*)"</code> 的部分保存在第一个捕获物中
（因此是编号 1 ）；
由 "<code>.</code>" 匹配到的字符是 2 号捕获物，
匹配到 "<code>%s*</code>" 的那部分是 3 号。


<p>
作为一个特例，空的捕获 <code>()</code> 将捕获到当前字符串的位置（它是一个数字）。
例如，如果将模式 <code>"()aa()"</code> 作用到字符串
<code>"flaaap"</code> 上，将产生两个捕获物：
3 和 5 。






<h3>6.4.2 &ndash; <a name="6.4.2">打包和解包用到的格式串</a></h3>

<p>
用于 <a href="#pdf-string.pack"><code>string.pack</code></a>，
<a href="#pdf-string.packsize"><code>string.packsize</code></a>，
<a href="#pdf-string.unpack"><code>string.unpack</code></a>
的第一个参数。
它是一个描述了需要创建或读取的结构之布局。


<p>
格式串是由转换选项构成的序列。
这些转换选项列在后面：

<ul>
<li><b><code>&lt;</code>: </b>设为小端编码</li>
<li><b><code>&gt;</code>: </b>设为大端编码</li>
<li><b><code>=</code>: </b>大小端遵循本地设置</li>
<li><b><code>![<em>n</em>]</code>: </b>将最大对齐数设为 <code>n</code>
（默认遵循本地对齐设置）</li>
<li><b><code>b</code>: </b>一个有符号字节 (<code>char</code>)</li>
<li><b><code>B</code>: </b>一个无符号字节 (<code>char</code>)</li>
<li><b><code>h</code>: </b>一个有符号 <code>short</code> （本地大小）</li>
<li><b><code>H</code>: </b>一个无符号 <code>short</code> （本地大小）</li>
<li><b><code>l</code>: </b>一个有符号 <code>long</code> （本地大小）</li>
<li><b><code>L</code>: </b>一个无符号 <code>long</code> （本地大小）</li>
<li><b><code>j</code>: </b>一个 <code>lua_Integer</code></li>
<li><b><code>J</code>: </b>一个 <code>lua_Unsigned</code></li>
<li><b><code>T</code>: </b>一个 <code>size_t</code> （本地大小）</li>
<li><b><code>i[<em>n</em>]</code>: </b>一个 <code>n</code> 字节长（默认为本地大小）的有符号 <code>int</code></li>
<li><b><code>I[<em>n</em>]</code>: </b>一个 <code>n</code> 字节长（默认为本地大小）的无符号 <code>int</code></li>
<li><b><code>f</code>: </b>一个 <code>float</code> （本地大小）</li>
<li><b><code>d</code>: </b>一个 <code>double</code> （本地大小）</li>
<li><b><code>n</code>: </b>一个 <code>lua_Number</code></li>
<li><b><code>c<em>n</em></code>: </b><code>n</code>字节固定长度的字符串</li>
<li><b><code>z</code>: </b>零结尾的字符串</li>
<li><b><code>s[<em>n</em>]</code>: </b>长度加内容的字符串，其长度编码为一个 <code>n</code> 字节（默认是个 <code>size_t</code>） 长的无符号整数。</li>
<li><b><code>x</code>: </b>一个字节的填充</li>
<li><b><code>X<em>op</em></code>: </b>按选项 <code>op</code> 的方式对齐（忽略它的其它方面）的一个空条目</li>
<li><b>'<code> </code>': </b>（空格）忽略</li>
</ul><p>
（ "<code>[<em>n</em>]</code>" 表示一个可选的整数。）
除填充、空格、配置项（选项 "<code>xX &lt;=&gt;!</code>"）外，
每个选项都关联一个参数（对于 <a href="#pdf-string.pack"><code>string.pack</code></a>）
或结果（对于 <a href="#pdf-string.unpack"><code>string.unpack</code></a>）。


<p>
对于选项 "<code>!<em>n</em></code>", "<code>s<em>n</em></code>", "<code>i<em>n</em></code>", "<code>I<em>n</em></code>",
<code>n</code> 可以是 1 到 16 间的整数。
所有的整数选项都将做溢出检查；
<a href="#pdf-string.pack"><code>string.pack</code></a> 检查提供的值是否能用指定的字长表示；
<a href="#pdf-string.unpack"><code>string.unpack</code></a> 检查读出的值能否置入 Lua 整数中。


<p>
任何格式串都假设有一个 "<code>!1=</code>" 前缀，
即最大对齐为 1 （无对齐）且采用本地大小端设置。


<p>
对齐行为按如下规则工作：
对每个选项，格式化时都会填充一些字节直到数据从一个特定偏移处开始，
这个位置是该选项的大小和最大对齐数中较小的那个数的倍数；
这个较小值必须是 2 个整数次方。
选项 "<code>c</code>" 及 "<code>z</code>" 不做对齐处理；
选项 "<code>s</code>" 对对齐遵循其开头的整数。


<p>
<a href="#pdf-string.pack"><code>string.pack</code></a> 用零去填充
（<a href="#pdf-string.unpack"><code>string.unpack</code></a> 则忽略它）。






<h2>6.5 &ndash; <a name="6.5">UTF-8 支持</a></h2>

<p>
这个库提供了对 UTF-8 编码的基础支持。
所有的函数都放在表 <a name="pdf-utf8"><code>utf8</code></a> 中。
此库不提供除编码处理之外的任何 Unicode 支持。
所有需要了解字符含义的操作，比如字符分类，都不在此范畴。


<p>
除非另有说明，
当一个函数需要一个字节位置的参数时，
都假定这个位置要么从字节序列的开始计算，
要么从字符串长度加一的位置算。
和字符串库一样，负的索引从字符串末尾计起。


<p>
<hr><h3><a name="pdf-utf8.char"><code>utf8.char (&middot;&middot;&middot;)</code></a></h3>
接收零或多个整数，
将每个整数转换成对应的 UTF-8 字节序列，并返回这些序列连接到一起的字符串。



<p>
<hr><h3><a name="pdf-utf8.charpattern"><code>utf8.charpattern</code></a></h3>
用于精确匹配到一个 UTF-8 字节序列的模式（是一个字符串，并非函数）"<code>[\0-\x7F\xC2-\xF4][\x80-\xBF]*</code>"
（参见 <a href="#6.4.1">&sect;6.4.1</a>）。
它假定处理的对象是一个合法的 UTF-8 字符串。



<p>
<hr><h3><a name="pdf-utf8.codes"><code>utf8.codes (s)</code></a></h3>


<p>
返回一系列的值，可以让

<pre>
     for p, c in utf8.codes(s) do <em>body</em> end
</pre><p>
迭代出字符串 <code>s</code> 中所有的字符。
这里的 <code>p</code> 是位置（按字节数）而 <code>c</code> 是每个字符的编号。
如果处理到一个不合法的字节序列，将抛出一个错误。



<p>
<hr><h3><a name="pdf-utf8.codepoint"><code>utf8.codepoint (s [, i [, j]])</code></a></h3>
以整数形式返回 <code>s</code> 中
从位置 <code>i</code> 到 <code>j</code> 间（包括两端）
所有字符的编号。
默认的 <code>i</code> 为 1 ，默认的 <code>j</code> 为 <code>i</code>。
如果碰上不合法的字节序列，抛出一个错误。



<p>
<hr><h3><a name="pdf-utf8.len"><code>utf8.len (s [, i [, j]])</code></a></h3>
返回字符串 <code>s</code> 中
从位置 <code>i</code> 到 <code>j</code> 间 （包括两端）
UTF-8 字符的个数。
默认的 <code>i</code> 为 1 ，默认的 <code>j</code> 为 -1 。
如果它找到任何不合法的字节序列，
返回假值加上第一个不合法字节的位置。



<p>
<hr><h3><a name="pdf-utf8.offset"><code>utf8.offset (s, n [, i])</code></a></h3>
返回编码在 <code>s</code> 中的第 <code>n</code> 个字符的开始位置（按字节数）
（从位置 <code>i</code> 处开始统计）。
负 <code>n</code> 则取在位置 <code>i</code> 前的字符。
当 <code>n</code> 是非负数时，默认的 <code>i</code> 是 1，
否则默认为 <code>#s + 1</code>。
因此，<code>utf8.offset(s, -n)</code> 取字符串的倒数第
<code>n</code> 个字符的位置。
如果指定的字符不在其中或在结束点之后，函数返回 <b>nil</b>。


<p>
作为特例，当 <code>n</code> 等于 0 时，
此函数返回含有 <code>s</code> 第 <code>i</code> 字节的那个字符的开始位置。


<p>
这个函数假定 <code>s</code> 是一个合法的 UTF-8 字符串。






<h2>6.6 &ndash; <a name="6.6">表处理</a></h2>

<p>
这个库提供了表处理的通用函数。
所有函数都放在表 <a name="pdf-table"><code>table</code></a> 中。


<p>
记住，无论何时，若一个操作需要取表的长度，
这张表必须是一个真序列，或是拥有 <code>__len</code> 元方法
（参见 <a href="#3.4.7">&sect;3.4.7</a> ）。
所有的函数都忽略传入参数的那张表中的非数字键。


<p>
<hr><h3><a name="pdf-table.concat"><code>table.concat (list [, sep [, i [, j]]])</code></a></h3>


<p>
提供一个列表，其所有元素都是字符串或数字，返回字符串
<code>list[i]..sep..list[i+1] &middot;&middot;&middot; sep..list[j]</code>。
<code>sep</code> 的默认值是空串，
<code>i</code> 的默认值是 1 ，
<code>j</code> 的默认值是 <code>#list</code> 。
如果 <code>i</code> 比 <code>j</code> 大，返回空串。




<p>
<hr><h3><a name="pdf-table.insert"><code>table.insert (list, [pos,] value)</code></a></h3>


<p>
在 <code>list</code> 的位置 <code>pos</code> 处插入元素 <code>value</code> ，
并后移元素 <code>list[pos], list[pos+1], &middot;&middot;&middot;, list[#list]</code> 。
<code>pos</code> 的默认值为 <code>#list+1</code> ，
因此调用 <code>table.insert(t,x)</code> 会将 <code>x</code> 插在列表 <code>t</code> 的末尾。



<p>
<hr><h3><a name="pdf-table.move"><code>table.move (a1, f, e, t [,a2])</code></a></h3>


<p>
将元素从表 <code>a1</code> 移到表 <code>a2</code>。
这个函数做了次等价于后面这个多重赋值的等价操作：
<code>a2[t],&middot;&middot;&middot; = a1[f],&middot;&middot;&middot;,a1[e]</code>。
<code>a2</code> 的默认值为 <code>a1</code>。
目标区间可以和源区间重叠。
索引 <code>f</code> 必须是正数。




<p>
<hr><h3><a name="pdf-table.pack"><code>table.pack (&middot;&middot;&middot;)</code></a></h3>


<p>
返回用所有参数以键 1,2, 等填充的新表，
并将 "<code>n</code>" 这个域设为参数的总数。
注意这张返回的表不一定是一个序列。



<p>
<hr><h3><a name="pdf-table.remove"><code>table.remove (list [, pos])</code></a></h3>


<p>
移除 <code>list</code> 中 <code>pos</code> 位置上的元素，并返回这个被移除的值。
当 <code>pos</code> 是在 1 到 <code>#list</code> 之间的整数时，
它向前移动元素　<code>list[pos+1], list[pos+2], &middot;&middot;&middot;, list[#list]</code>
并删除元素 <code>list[#list]</code>；
索引 <code>pos</code> 可以是 <code>#list + 1</code> ，或在 <code>#list</code> 为 0 时可以是 0 ；
在这些情况下，函数删除元素 <code>list[pos]</code>。


<p>
<code>pos</code> 默认为 <code>#list</code>，
因此调用 <code>table.remove(l)</code> 将移除表 <code>l</code> 的最后一个元素。



<p>
<hr><h3><a name="pdf-table.sort"><code>table.sort (list [, comp])</code></a></h3>


<p>
在表内从 <code>list[1]</code> 到 <code>list[#list]</code> <em>原地</em> 
对其间元素按指定次序排序。
如果提供了 <code>comp</code> ，
它必须是一个可以接收两个列表内元素为参数的函数。
当第一个元素需要排在第二个元素之前时，返回真
（因此 <code>not comp(list[i+1],list[i])</code> 在排序结束后将为真）。
如果没有提供 <code>comp</code>，
将使用标准 Lua 操作 <code>&lt;</code> 作为替代品。


<p>
排序算法并不稳定；
即当两个元素次序相等时，它们在排序后的相对位置可能会改变。




<p>
<hr><h3><a name="pdf-table.unpack"><code>table.unpack (list [, i [, j]])</code></a></h3>


<p>
返回列表中的元素。
这个函数等价于

<pre>
     return list[i], list[i+1], &middot;&middot;&middot;, list[j]
</pre><p>
<code>i</code> 默认为 1 ，<code>j</code> 默认为 <code>#list</code>。






<h2>6.7 &ndash; <a name="6.7">数学函数</a></h2>

<p>
这个库提供了基本的数学函数。
所以函数都放在表 <a name="pdf-math"><code>math</code></a> 中。
注解有 "<code>integer/float</code>" 的函数会对整数参数返回整数结果，
对浮点（或混合）参数返回浮点结果。
圆整函数（<a href="#pdf-math.ceil"><code>math.ceil</code></a>, <a href="#pdf-math.floor"><code>math.floor</code></a>, <a href="#pdf-math.modf"><code>math.modf</code></a>）
在结果在整数范围内时返回整数，否则返回浮点数。

<p>
<hr><h3><a name="pdf-math.abs"><code>math.abs (x)</code></a></h3>


<p>
返回 <code>x</code> 的绝对值。(integer/float)




<p>
<hr><h3><a name="pdf-math.acos"><code>math.acos (x)</code></a></h3>


<p>
返回 <code>x</code> 的反余弦值（用弧度表示）。




<p>
<hr><h3><a name="pdf-math.asin"><code>math.asin (x)</code></a></h3>


<p>
返回 <code>x</code> 的反正弦值（用弧度表示）。



<p>
<hr><h3><a name="pdf-math.atan"><code>math.atan (y [, x])</code></a></h3>


<p>
返回 <code>y/x</code> 的反正切值（用弧度表示）。
它会使用两个参数的符号来找到结果落在哪个象限中。
（即使 <code>x</code> 为零时，也可以正确的处理。）

<p>
默认的 <code>x</code> 是 1 ，
因此调用 <code>math.atan(y)</code> 将返回
<code>y</code> 的反正切值。




<p>
<hr><h3><a name="pdf-math.ceil"><code>math.ceil (x)</code></a></h3>


<p>
返回不小于 <code>x</code> 的最小整数值。



<p>
<hr><h3><a name="pdf-math.cos"><code>math.cos (x)</code></a></h3>


<p>
返回 <code>x</code> 的余弦（假定参数是弧度）。



<p>
<hr><h3><a name="pdf-math.deg"><code>math.deg (x)</code></a></h3>


<p>
将角 <code>x</code> 从弧度转换为角度。


<p>
<hr><h3><a name="pdf-math.exp"><code>math.exp (x)</code></a></h3>


<p>
返回 <em>e<sup>x</sup></em> 的值
（<code>e</code> 为自然对数的底）。



<p>
<hr><h3><a name="pdf-math.floor"><code>math.floor (x)</code></a></h3>


<p>
返回不大于 <code>x</code> 的最大整数值。



<p>
<hr><h3><a name="pdf-math.fmod"><code>math.fmod (x, y)</code></a></h3>


<p>
返回 <code>x</code> 除以 <code>y</code>，将商向零圆整后的余数。
(integer/float)




<p>
<hr><h3><a name="pdf-math.huge"><code>math.huge</code></a></h3>


<p>
浮点数 <code>HUGE_VAL</code>，
这个数比任何数字值都大。


<p>
<hr><h3><a name="pdf-math.log"><code>math.log (x [, base])</code></a></h3>


<p>
返回以指定底的 <code>x</code> 的对数。
默认的 <code>base</code> 是 <em>e</em>
（因此此函数返回 <code>x</code> 的自然对数）。


<p>
<hr><h3><a name="pdf-math.max"><code>math.max (x, &middot;&middot;&middot;)</code></a></h3>


<p>
返回参数中最大的值，
大小由 Lua 操作 <code>&lt;</code> 决定。
(integer/float)




<p>
<hr><h3><a name="pdf-math.maxinteger"><code>math.maxinteger</code></a></h3>
最大值的整数。




<p>
<hr><h3><a name="pdf-math.min"><code>math.min (x, &middot;&middot;&middot;)</code></a></h3>


<p>
返回参数中最小的值，
大小由 Lua 操作 <code>&lt;</code> 决定。
(integer/float)



<p>
<hr><h3><a name="pdf-math.mininteger"><code>math.mininteger</code></a></h3>
最小值的整数。



<p>
<hr><h3><a name="pdf-math.modf"><code>math.modf (x)</code></a></h3>


<p>
返回 <code>x</code> 的整数部分和小数部分。
第二个结果一定是浮点数。



<p>
<hr><h3><a name="pdf-math.pi"><code>math.pi</code></a></h3>


<p>
<em>&pi;</em> 的值。




<p>
<hr><h3><a name="pdf-math.rad"><code>math.rad (x)</code></a></h3>


<p>
将角 <code>x</code> 从角度转换为弧度。



<p>
<hr><h3><a name="pdf-math.random"><code>math.random ([m [, n]])</code></a></h3>


<p>
当不带参数调用时，
返回一个 <em>[0,1)</em> 区间内一致分布的浮点伪随机数。
当以两个整数 <code>m</code> 与 <code>n</code> 调用时，
<code>math.random</code> 返回一个 <em>[m, n]</em> 区间
内一致分布的整数伪随机数。
（值 <em>n-m</em> 不能是负数，且必须在 Lua 整数的表示范围内。）
调用 <code>math.random(n)</code> 等价于 <code>math.random(1,n)</code>。


<p>
这个函数是对 C 提供的位随机数函数的封装。
对其统计属性不作担保。



<p>
<hr><h3><a name="pdf-math.randomseed"><code>math.randomseed (x)</code></a></h3>


<p>
把 <code>x</code> 设为伪随机数发生器的“种子”：
相同的种子产生相同的随机数列。



<p>
<hr><h3><a name="pdf-math.sin"><code>math.sin (x)</code></a></h3>


<p>
返回 <code>x</code> 的正弦值（假定参数是弧度）。



<p>
<hr><h3><a name="pdf-math.sqrt"><code>math.sqrt (x)</code></a></h3>


<p>
返回 <code>x</code> 的平方根。
（你也可以使用乘方 <code>x^0.5</code> 来计算这个值。）



<p>
<hr><h3><a name="pdf-math.tan"><code>math.tan (x)</code></a></h3>


<p>
返回 <code>x</code> 的正切值（假定参数是弧度）。




<p>
<hr><h3><a name="pdf-math.tointeger"><code>math.tointeger (x)</code></a></h3>


<p>
如果 <code>x</code> 可以转换为一个整数，
返回该整数。
否则返回 <b>nil</b>。




<p>
<hr><h3><a name="pdf-math.type"><code>math.type (x)</code></a></h3>


<p>
如果 <code>x</code> 是整数，返回 "<code>integer</code>"，
如果它是浮点数，返回 "<code>float</code>"，
如果 <code>x</code> 不是数字，返回 <b>nil</b>。



<p>
<hr><h3><a name="pdf-math.ult"><code>math.ult (m, n)</code></a></h3>


<p>
如果整数 <code>m</code> 和 <code>n</code> 以无符号整数形式比较，
<code>m</code> 在 <code>n</code> 之下，返回布尔真否则返回假。


<h2>6.9 &ndash; <a name="6.9">操作系统库</a></h2>

<p>
这个库都通过表 <a name="pdf-os"><code>os</code></a> 实现。


<p>
<hr><h3><a name="pdf-os.clock"><code>os.clock ()</code></a></h3>


<p>
返回程序使用的按秒计 CPU 时间的近似值。



<p>
<hr><h3><a name="pdf-os.date"><code>os.date ([format [, time]])</code></a></h3>


<p>
返回一个包含日期及时刻的字符串或表。
格式化方法取决于所给字符串 <code>format</code>。


<p>
如果提供了 <code>time</code> 参数，
格式化这个时间
（这个值的含义参见 <a href="#pdf-os.time"><code>os.time</code></a> 函数）。
否则，<code>date</code> 格式化当前时间。


<p>
如果 <code>format</code> 以 '<code>!</code>' 打头，
日期以协调世界时格式化。
在这个可选字符项之后，
如果 <code>format</code> 为字符串 "<code>*t</code>"，
<code>date</code> 返回有后续域的表：
<code>year</code> （四位数字），<code>month</code> （1&ndash;12），<code>day</code> （1&ndash;31），
<code>hour</code> （0&ndash;23），<code>min</code> （0&ndash;59），<code>sec</code> （0&ndash;61），
<code>wday</code> （星期几，星期天为 1 ），
<code>yday</code> （当年的第几天），
以及 <code>isdst</code> （夏令时标记，一个布尔量）。
对于最后一个域，如果该信息不提供的话就不存在。


<p>
如果 <code>format</code> 并非 "<code>*t</code>"，
<code>date</code> 以字符串形式返回，
格式化方法遵循 ISO C 函数 <code>strftime</code> 的规则。


<p>
如果不传参数调用，
<code>date</code> 返回一个合理的日期时间串，
格式取决于宿主程序以及当前的区域设置
（即，<code>os.date()</code> 等价于 <code>os.date("%c")</code>）。


<p>
在非 POSIX 系统上，
由于这个函数依赖 C 函数 <code>gmtime</code> 和 <code>localtime</code>，
它可能并非线程安全的。



<p>
<hr><h3><a name="pdf-os.difftime"><code>os.difftime (t2, t1)</code></a></h3>


<p>
返回以秒计算的时刻 <code>t1</code> 到 <code>t2</code> 的差值。
（这里的时刻是由 <a href="#pdf-os.time"><code>os.time</code></a> 返回的值）。
在 POSIX，Windows，和其它一些系统中，这个值就等于
<code>t2</code><em>-</em><code>t1</code>。



<p>
<hr><h3><a name="pdf-os.execute"><code>os.execute ([command])</code></a></h3>


<p>
这个函数等价于 ISO C 函数 <code>system</code>。
它调用系统解释器执行 <code>command</code>。
如果命令成功运行完毕，第一个返回值就是 <b>true</b>，
否则是 <b>nil</b> otherwise。
在第一个返回值之后，函数返回一个字符串加一个数字。如下：
<ul>

<li><b>"<code>exit</code>": </b>
命令正常结束；
接下来的数字是命令的退出状态码。
</li>

<li><b>"<code>signal</code>": </b>
命令被信号打断；
接下来的数字是打断该命令的信号。
</li>

</ul>

<p>
如果不带参数调用，
<code>os.execute</code> 在系统解释器存在的时候返回真。



<p>
<hr><h3><a name="pdf-os.exit"><code>os.exit ([code [, close]])</code></a></h3>


<p>
调用 ISO C 函数 <code>exit</code> 终止宿主程序。
如果 <code>code</code> 为 <b>true</b>，
返回的状态码是 <code>EXIT_SUCCESS</code>；
如果 <code>code</code> 为 <b>false</b>，
返回的状态码是 <code>EXIT_FAILURE</code>；
如果 <code>code</code> 是一个数字，
返回的状态码就是这个数字。
<code>code</code> 的默认值为 <b>true</b>。


<p>
如果第二个可选参数 <code>close</code> 为真，
在退出前关闭 Lua 状态机。



<p>
<hr><h3><a name="pdf-os.getenv"><code>os.getenv (varname)</code></a></h3>


<p>
返回进程环境变量 <code>varname</code> 的值，
如果该变量未定义，返回 <b>nil</b> 。




<p>
<hr><h3><a name="pdf-os.remove"><code>os.remove (filename)</code></a></h3>


<p>
删除指定名字的文件（在 POSIX 系统上可以是一个空目录）
如果函数失败，返回 <b>nil</b>
加一个错误描述串及出错码。



<p>
<hr><h3><a name="pdf-os.rename"><code>os.rename (oldname, newname)</code></a></h3>


<p>
将名字为 <code>oldname</code> 的文件或目录更名为 <code>newname</code>。
如果函数失败，返回 <b>nil</b>
加一个错误描述串及出错码。



<p>
<hr><h3><a name="pdf-os.setlocale"><code>os.setlocale (locale [, category])</code></a></h3>


<p>
设置程序的当前区域。
<code>locale</code> 是一个区域设置的系统相关字符串；
<code>category</code> 是一个描述有改变哪个分类的可选字符串：
<code>"all"</code>，<code>"collate"</code>， <code>"ctype"</code>，
<code>"monetary"</code>， <code>"numeric"</code>， 或 <code>"time"</code>；
默认的分类为 <code>"all"</code>。
此函数返回新区域的名字。
如果请求未被获准，返回 <b>nil</b> 。


<p>
当 <code>locale</code> 是一个空串，
当前区域被设置为一个在实现中定义好的本地区域。
当 <code>locale</code> 为字符串 "<code>C</code>"，
当前区域被设置为标准 C 区域。


<p>
当第一个参数为 <b>nil</b> 时，
此函数仅返回当前区域指定分类的名字。


<p>
由于这个函数依赖 C 函数 <code>setlocale</code>，
它可能并非线程安全的。



<p>
<hr><h3><a name="pdf-os.time"><code>os.time ([table])</code></a></h3>


<p>
当不传参数时，返回当前时刻。
如果传入一张表，就返回由这张表表示的时刻。
这张表必须包含域 <code>year</code>，<code>month</code>，及 <code>day</code>；
可以包含有　<code>hour</code> （默认为 12 ），
<code>min</code> （默认为 0），
<code>sec</code> （默认为 0），以及 <code>isdst</code> （默认为 <b>nil</b>）。
关于这些域的详细描述，参见 <a href="#pdf-os.date"><code>os.date</code></a> 函数。


<p>
返回值是一个含义由你的系统决定的数字。
在 POSIX，Windows，和其它一些系统中，
这个数字统计了从指定时间（"epoch"）开始经历的秒数。
对于另外的系统，其含义未定义，
你只能把 <code>time</code> 的返回数字用于
<a href="#pdf-os.date"><code>os.date</code></a> 和 <a href="#pdf-os.difftime"><code>os.difftime</code></a>
的参数。



<p>
<hr><h3><a name="pdf-os.tmpname"><code>os.tmpname ()</code></a></h3>


<p>
返回一个可用于临时文件的文件名字符串。
这个文件在使用前必须显式打开，不再使用时需要显式删除。

<p>
在 POSIX 系统上，
这个函数会以此文件名创建一个文件以回避安全风险。
（别人可能未经允许在获取到这个文件名到创建该文件之间的时刻创建此文件。）
你依旧需要在使用它的时候先打开，并最后删除（即使你没使用到）。

<p>
只有有可能，你更应该使用
<a href="#pdf-io.tmpfile"><code>io.tmpfile</code></a>，
因为该文件可以在程序结束时自动删除。


<HR>
<SMALL CLASS="footer">
最后更新时间：
2019年1月18日19:54
</SMALL>

</body></html>

